include "lib/def.kc"
include "lib/util.kc"
include "lib/fs.kc"
include "lib/malloc.kc"
include "lib/map.kc"
include "lib/vec.kc"
include "compiler/compiler.kc"
include "boot/task.kc"
include "adam/task.kc"
include "adam/vbe.kc"
include "adam/font.kc"
include "adam/keyboard.kc"
include "adam/window.kc"
include "adam/mouse.kc"

global ans;

function eve(compiler)
(c{3}, olm, orm, omm, w, k)
{
    adam_key_events = malloc(VEC);
    adam_mouse_events = malloc(VEC);
    vec_init(adam_key_events, 64, 1);
    vec_init(adam_mouse_events, 64, 3);
    set_resolution(1024, 768);
    screen_fill_rect(0, 0, fb_width, fb_height, 0x5C96C9);
    init_mouse();
    create_window(8, 8, 512, 128);

    print("
i i i i i i i      mmmmmmm   mm   m      m    m m    m mmmm  
I I I I I I I         #      ##   #      ##  ## #    # #   \"m
I  \\ `+' /  I         #     #  #  #      # ## # #    # #    #
 \\  `-+-'  /          #     #mm#  #      # \"\" # #    # #    #
  `-__|__-'           #    #    # #mmmmm #    # \"mmmm\" #mmm\" 
      |
------+------

Welcome to TalmudOS (Formerly ChucksOS)
");

    new_task("Seth", seth, 0);

    draw_cursor();
    while (TRUE)
    {
        if (adam_key_events.[VEC_LEN] == 0 and adam_mouse_events.[VEC_LEN] == 0)
        {
            wait();
        }
        else if (adam_key_events.[VEC_LEN])
        {
            CLI
            vec_shift(adam_key_events, c);
            STI
            k = 0;
            if (c{0} == 0xE0)
            {
                while (adam_key_events.[VEC_LEN] == 0) wait();
                CLI
                vec_shift(adam_key_events, c);
                STI
                k = 0x100;
            }
            k |= c{0};
            if (k & 0x80) k ^= K_RELEASED | (c{0} & 0x80);
            if (k == K_LSHIFT or k == K_RSHIFT) shift_pressed = TRUE;
            else if (k == (K_LSHIFT | K_RELEASED) or k == (K_RSHIFT | K_RELEASED)) shift_pressed = FALSE;
            if (k == K_LCTRL) ctrl_pressed = TRUE;
            else if (k == (K_LCTRL | K_RELEASED)) ctrl_pressed = FALSE;
            if (k == K_LALT) alt_pressed = TRUE;
            else if (k == (K_LALT | K_RELEASED)) alt_pressed = TRUE;

            if (k == K_T and ctrl_pressed and alt_pressed)
            {
                new_task("Seth", seth, 0);
            }
            else
            {
                vec_push2(&windows{WINDOW_KEY_EVENTS}, k);
                windows.[WINDOW_TASK].[TASK_WAIT] = FALSE;
            }
        }
        else
        {
            CLI
            vec_shift(adam_mouse_events, c);
            STI
            cursor_x += (c{0} & 16) ? -0x100 + c{1} : c{1};
            if (cursor_x <$ 0) cursor_x = 0;
            if (cursor_x >=$ fb_width) cursor_x = fb_width - 1;
            cursor_y -= (c{0} & 32) ? -0x100 + c{2} : c{2};
            if (cursor_y <$ 0) cursor_y = 0;
            if (cursor_y >=$ fb_height) cursor_y = fb_height - 1;
            draw_cursor();
            format(print, "mouse: %dx%dy               \r", cursor_x, cursor_y);

            w = windows;
            while (w and !(w.[WINDOW_X] <! cursor_x + CURSOR_W and cursor_x <! w.[WINDOW_X] + w.[WINDOW_W] + BORDER_SIZE *! 2 and w.[WINDOW_Y] <! cursor_y + CURSOR_H and cursor_y <! w.[WINDOW_Y] + w.[WINDOW_H] + BORDER_SIZE *! 2))
            {
                w = w.[WINDOW_BELOW];
            }
            if (w)
            {
                if (c{0} & 1 and !olm)
                {
                    format(print, "lmb down on window %s\n", &w.[WINDOW_TASK]{TASK_NAME});
                    focus_window(w);
                }
                else if (!(c{0} & 1) and olm)
                {
                    format(print, "lmb up on window %s\n", &w.[WINDOW_TASK]{TASK_NAME});
                }
            }
            
            olm = c{0} & 1;
            orm = c{0} & 2;
            omm = c{0} & 4;
        }
    }
}

function seth(u)
(v{VEC}, p{VEC}, x)
{
    create_window(200, 200, 640, 480);
    vec_init(v, 128, 1);
    vec_init(p, 128, 1);
    while (TRUE)
    {
        dir2path(p, &task{TASK_CWD});
        format(print, "%s> ", p);
        x = compile(&task{TASK_COMPILER}, "stdin", input(v));
        if (x)
        {
            v.[VEC_LEN] = 0;
            ans = x();
            format(print, "ans=%d (%x)\n", ans, ans);
        }
        else
        {
            if (task.[TASK_COMPILER + CCUR + TOKEN_TYPE] != TEND) v.[VEC_LEN] = 0;
        }
    }
}

function dir(p)
(f{FILE}, d{DIR_ENTRY}, s{STRING})
{
    if (!open(p, f, FALSE)) return format(print, "Could not open path \"%s\"\n", p);
    s.[STRINGLEN] = 11;
    s.[STRINGPTR] = &d{DIR_ENTRY_83NAME};
    while (dir_next(f, d))
    {
        format(print, "%s\n", s);
    }
}

function intcmp(x, y) return x[0] == y[0];
function hashint(x) return *x;
function memrep()
(m{MAP}, i, freemem, usedmem, n)
{
    map_init(m, 8, 4, 4, intcmp, hashint, NULL);
    i = first_free;
    freemem = 0;
    usedmem = 0;
    while (i)
    {
        if (!(i{MEM_HEADER_FLAGS} & MEM_HEADER_FUSED))
        {
            freemem += i.[MEM_HEADER_SIZE];
        }
        else
        {
            usedmem += i.[MEM_HEADER_SIZE];
            if (map_get(m, &i{MEM_HEADER_TASK}, &n))
            {
                n += i.[MEM_HEADER_SIZE];
                map_set(m, &i{MEM_HEADER_TASK}, &n);
            }
            else
            {
                map_set(m, &i{MEM_HEADER_TASK}, &i.[MEM_HEADER_SIZE]);
            }
        }
        i = i.[MEM_HEADER_NEXT];
    }
    format(print, "%dM free, %dK used, %dK reserved for YHWH\n", freemem /! 1024 /! 1024, usedmem /! 1024, (first_free - 0x500) /! 1024);
    n = 0;
    while (map_iter(m, &n))
    {
        format(print, "%dK used by task %s\n", n[1] /! 1024, &n[0]{TASK_NAME});
    }
    map_free(m);
}