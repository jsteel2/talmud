include "lib/def.kc"
include "lib/util.kc"
include "lib/fs.kc"
include "lib/malloc.kc"
include "lib/map.kc"
include "lib/vec.kc"
include "compiler/compiler.kc"
include "adam/task.kc"
include "adam/vbe.kc"
include "adam/font.kc"
include "adam/window.kc"
include "adam/keyboard.kc"
include "adam/mouse.kc"

global ans;

function eve(compiler)
(c{3}, mx, my, cb{8 *! 8 *! 4})
{
    adam_key_events = malloc(VEC);
    adam_mouse_events = malloc(VEC);
    vec_init(adam_key_events, 64, 1);
    vec_init(adam_mouse_events, 64, 3);
    set_resolution(1024, 768);
    screen_fill_rect(0, 0, 1024, 768, 0xFFFFFF);
    init_mouse();
    create_window();

    print("
i i i i i i i      mmmmmmm   mm   m      m    m m    m mmmm  
I I I I I I I         #      ##   #      ##  ## #    # #   \"m
I  \\ `+' /  I         #     #  #  #      # ## # #    # #    #
 \\  `-+-'  /          #     #mm#  #      # \"\" # #    # #    #
  `-__|__-'           #    #    # #mmmmm #    # \"mmmm\" #mmm\" 
      |
------+------

Welcome to TalmudOS (Formerly ChucksOS)
");

    new_task(seth, 0);

    mx = 0;
    my = 0;
    backbuffer_read_rect(mx, my, minu(8, fb_width - mx), minu(8, fb_height - my), cb);
    screen_fill_rect(mx, my, minu(8, fb_width - mx), minu(8, fb_height - my), 0xFF0000);
    while (TRUE)
    {
        if (adam_key_events.[VEC_LEN] == 0 and adam_mouse_events.[VEC_LEN] == 0)
        {
            wait();
        }
        else if (adam_key_events.[VEC_LEN])
        {
            CLI
            vec_shift(adam_key_events, c);
            STI
            vec_push1(&focused_window{WINDOW_KEY_EVENTS}, c{0});
            focused_window.[WINDOW_TASK].[TASK_WAIT] = FALSE;
        }
        else
        {
            CLI
            vec_shift(adam_mouse_events, c);
            STI
            screen_write_rect(mx, my, minu(8, fb_width - mx), minu(8, fb_height - my), cb);
            mx += (c{0} & 16) ? -0x100 + c{1} : c{1};
            if (mx <$ 0) mx = 0;
            if (mx >=$ fb_width) mx = fb_width - 1;
            my -= (c{0} & 32) ? -0x100 + c{2} : c{2};
            if (my <$ 0) my = 0;
            if (my >=$ fb_height) my = fb_height - 1;
            backbuffer_read_rect(mx, my, minu(8, fb_width - mx), minu(8, fb_height - my), cb);
            screen_fill_rect(mx, my, minu(8, fb_width - mx), minu(8, fb_height - my), 0xFF0000);
        }
    }
}

function seth(u)
(v{VEC}, x)
{
    create_window();
    vec_init(v, 128, 1);
    while (TRUE)
    {
        print("> ");
        x = compile(&task{TASK_COMPILER}, "stdin", input(v));
        if (x)
        {
            v.[VEC_LEN] = 0;
            ans = x();
            format(print, "ans=%d (%x)\n", ans, ans);
        }
        else
        {
            if (task.[TASK_COMPILER + CCUR + TOKEN_TYPE] != TEND) v.[VEC_LEN] = 0;
        }
    }
}

global print_x, print_y;
function print(s)
(i)
{
    i = 0;
    while (i <! s.[STRINGLEN])
    {
        if (s.[STRINGPTR]{i} == '\n')
        {
            print_x = 0;
            print_y += 8;
        }
        else if (s.[STRINGPTR]{i} == '\b')
        {
            print_x -= 8;
            screen_fill_rect(print_x, print_y, 8, 8, 0xFFFFFF);
        }
        else
        {
            screen_draw_char(s.[STRINGPTR]{i}, print_x, print_y, 0x000000);
            print_x += 8;
            if (print_x + 8 >! fb_width)
            {
                print_x = 0;
                print_y += 8;
            }
        }
        if (print_y + 8 >! fb_height)
        {
            screen_fill_rect(0, 0, 1024, 768, 0xFFFFFF);
            print_x = 0;
            print_y = 0;
        }
        i += 1;
    }
}

global shift_pressed;
function input(vec)
(c)
{
    c = 0;
    while (TRUE)
    {
.l:
        if (task.[TASK_WINDOW].[WINDOW_KEY_EVENTS + VEC_LEN] == 0)
        {
            wait();
        }
        else
        {
            if (!vec_shift(&task.[TASK_WINDOW]{WINDOW_KEY_EVENTS}, &c)) break;
            if (c == 0x2A or c == 0x36) { shift_pressed = TRUE; JMP .l }
            else if (c == 0xAA or c == 0xB6) shift_pressed = FALSE;
            if (c & 0x80) JMP .l
            c = shift_pressed ? qwerty_upper{c} : qwerty{c};
            format(print, "%c", c);
            if (c == '\n') break;
            if (c == '\b')
            {
                if (vec.[VEC_LEN] != 0) vec.[VEC_LEN] -= 1;
                JMP .l
            }
            vec_push1(vec, c);
        }
    }
    return vec;
}