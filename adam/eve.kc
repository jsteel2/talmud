include "lib/def.kc"
include "lib/util.kc"
include "lib/fs.kc"
include "lib/malloc.kc"
include "lib/map.kc"
include "lib/vec.kc"
include "compiler/compiler.kc"
include "boot/task.kc"
include "adam/task.kc"
include "adam/vbe.kc"
include "adam/font.kc"
include "adam/keyboard.kc"
include "adam/window.kc"
include "adam/mouse.kc"

global ans;

function eve(compiler)
(c{3})
{
    adam_key_events = malloc(VEC);
    adam_mouse_events = malloc(VEC);
    vec_init(adam_key_events, 64, 1);
    vec_init(adam_mouse_events, 64, 3);
    set_resolution(1024, 768);
    screen_fill_rect(0, 0, fb_width, fb_height, 0x5C96C9);
    init_mouse();
    create_window(8, 8, 512, 128);

    print("
i i i i i i i      mmmmmmm   mm   m      m    m m    m mmmm  
I I I I I I I         #      ##   #      ##  ## #    # #   \"m
I  \\ `+' /  I         #     #  #  #      # ## # #    # #    #
 \\  `-+-'  /          #     #mm#  #      # \"\" # #    # #    #
  `-__|__-'           #    #    # #mmmmm #    # \"mmmm\" #mmm\" 
      |
------+------

Welcome to TalmudOS (Formerly ChucksOS)
");

    new_task(seth, 0);

    draw_cursor();
    while (TRUE)
    {
        if (adam_key_events.[VEC_LEN] == 0 and adam_mouse_events.[VEC_LEN] == 0)
        {
            wait();
        }
        else if (adam_key_events.[VEC_LEN])
        {
            CLI
            vec_shift(adam_key_events, c);
            STI
            if (c{0} == 0x2A or c{0} == 0x36) shift_pressed = TRUE;
            else if (c{0} == 0xAA or c{0} == 0xB6) shift_pressed = FALSE;
            if (c{0} == 0x1D) ctrl_pressed = TRUE;
            else if (c{0} == 0x9D) ctrl_pressed = FALSE;
            if (c{0} == 0x38) alt_pressed = TRUE;
            else if (c{0} == 0xB8) alt_pressed = TRUE;

            if (c{0} == 0x14 and ctrl_pressed and alt_pressed)
            {
                new_task(seth, 0);
            }
            else
            {
                vec_push1(&windows{WINDOW_KEY_EVENTS}, c{0});
                windows.[WINDOW_TASK].[TASK_WAIT] = FALSE;
            }
        }
        else
        {
            CLI
            vec_shift(adam_mouse_events, c);
            STI
            cursor_x += (c{0} & 16) ? -0x100 + c{1} : c{1};
            if (cursor_x <$ 0) cursor_x = 0;
            if (cursor_x >=$ fb_width) cursor_x = fb_width - 1;
            cursor_y -= (c{0} & 32) ? -0x100 + c{2} : c{2};
            if (cursor_y <$ 0) cursor_y = 0;
            if (cursor_y >=$ fb_height) cursor_y = fb_height - 1;
            draw_cursor();
            format(print, "mouse: %dx%dy               \r", cursor_x, cursor_y);
        }
    }
}

function seth(u)
(v{VEC}, p{VEC}, x)
{
    create_window(200, 200, 640, 480);
    vec_init(v, 128, 1);
    vec_init(p, 128, 1);
    while (TRUE)
    {
        dir2path(p, &task{TASK_CWD});
        format(print, "%s> ", p);
        x = compile(&task{TASK_COMPILER}, "stdin", input(v));
        if (x)
        {
            v.[VEC_LEN] = 0;
            ans = x();
            format(print, "ans=%d (%x)\n", ans, ans);
        }
        else
        {
            if (task.[TASK_COMPILER + CCUR + TOKEN_TYPE] != TEND) v.[VEC_LEN] = 0;
        }
    }
}

function dir(p)
(f{FILE}, d{DIR_ENTRY}, s{STRING})
{
    if (!open(p, f, FALSE)) return format(print, "Could not open path \"%s\"\n", p);
    s.[STRINGLEN] = 11;
    s.[STRINGPTR] = &d{DIR_ENTRY_83NAME};
    while (dir_next(f, d))
    {
        format(print, "%s\n", s);
    }
}