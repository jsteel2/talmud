struct WINDOW = VEC{WINDOW_KEY_EVENTS}, [WINDOW_TASK], [WINDOW_X], [WINDOW_Y], [WINDOW_W], [WINDOW_H], [WINDOW_PRINT_X], [WINDOW_PRINT_Y];
const BORDER_SIZE = 4;

global focused_window;

function create_window(x, y, w, h)
(win)
{
    win = malloc(WINDOW);
    vec_init(&win{WINDOW_KEY_EVENTS}, 32, 1);
    win.[WINDOW_TASK] = task;
    win.[WINDOW_X] = x;
    win.[WINDOW_Y] = y;
    win.[WINDOW_W] = w;
    win.[WINDOW_H] = h;
    win.[WINDOW_PRINT_X] = 0;
    win.[WINDOW_PRINT_Y] = 0;
    window_draw_border(win);
    focused_window = task.[TASK_WINDOW] = win;
    return win;
}

function window_draw_border(w)
{
    screen_fill_rect(w.[WINDOW_X], w.[WINDOW_Y], w.[WINDOW_W] + BORDER_SIZE, BORDER_SIZE, 0xFF);
    screen_fill_rect(w.[WINDOW_X], w.[WINDOW_Y] + BORDER_SIZE, BORDER_SIZE, w.[WINDOW_H] + BORDER_SIZE, 0xFF);
    screen_fill_rect(w.[WINDOW_X], w.[WINDOW_Y] + w.[WINDOW_H] + BORDER_SIZE, w.[WINDOW_W] + BORDER_SIZE, BORDER_SIZE, 0xFF);
    screen_fill_rect(w.[WINDOW_X] + w.[WINDOW_W] + BORDER_SIZE, w.[WINDOW_Y], BORDER_SIZE, w.[WINDOW_H] + BORDER_SIZE *! 2, 0xFF);
}

function fill_rect(x, y, w, h, c)
(win)
{
    win = task.[TASK_WINDOW];
    screen_fill_rect(win.[WINDOW_X] + BORDER_SIZE + x, win.[WINDOW_Y] + BORDER_SIZE + y, w, h, c);
}

function draw_char(c, x, y, color, bg)
(win)
{
    win = task.[TASK_WINDOW];
    screen_draw_char(c, win.[WINDOW_X] + BORDER_SIZE + x, win.[WINDOW_Y] + BORDER_SIZE + y, color, bg);
}

function print(s)
(i, w)
{
    w = task.[TASK_WINDOW];
    i = 0;
    while (i <! s.[STRINGLEN])
    {
        if (s.[STRINGPTR]{i} == '\n')
        {
            w.[WINDOW_PRINT_X] = 0;
            w.[WINDOW_PRINT_Y] += 8;
        }
        else if (s.[STRINGPTR]{i} == '\b')
        {
            w.[WINDOW_PRINT_X] -= 8;
        }
        else if (s.[STRINGPTR]{i} == '\r')
        {
            w.[WINDOW_PRINT_X] = 0;
        }
        else
        {
            draw_char(s.[STRINGPTR]{i}, w.[WINDOW_PRINT_X], w.[WINDOW_PRINT_Y], 0x000000, 0xFFFFFF);
            w.[WINDOW_PRINT_X] += 8;
            if (w.[WINDOW_PRINT_X] + 8 >! w.[WINDOW_W])
            {
                w.[WINDOW_PRINT_X] = 0;
                w.[WINDOW_PRINT_Y] += 8;
            }
        }
        if (w.[WINDOW_PRINT_Y] + 8 >! w.[WINDOW_H])
        {
            fill_rect(0, 0, w.[WINDOW_W], w.[WINDOW_H], 0xFFFFFF);
            w.[WINDOW_PRINT_X] = 0;
            w.[WINDOW_PRINT_Y] = 0;
        }
        i += 1;
    }
}

function input(vec)
(c)
{
    c = 0;
    while (TRUE)
    {
.l:
        if (task.[TASK_WINDOW].[WINDOW_KEY_EVENTS + VEC_LEN] == 0)
        {
            wait();
        }
        else
        {
            if (!vec_shift(&task.[TASK_WINDOW]{WINDOW_KEY_EVENTS}, &c)) break;
            if (c & 0x80 or c == 0x2A or c == 0x36) JMP .l
            c = shift_pressed ? qwerty_upper{c} : qwerty{c};
            if (c == '\b')
            {
                if (vec.[VEC_LEN] != 0)
                {
                    vec.[VEC_LEN] -= 1;
                    print("\b \b");
                }
                JMP .l
            }
            format(print, "%c", c);
            if (c == '\n') break;
            vec_push1(vec, c);
        }
    }
    return vec;
}