ORG 0x500
USE16

const STACK = $! + 48 *! 1024;
const DISK_BUF = STACK;

IN AL, 0x92
OR AL, 2
OUT 0x92, AL

MOV ESI, pmode
JMP switch_protected

USE32
pmode:
    MOV ESP, STACK

function eden()
(file{FILE}, r, eve, s[STRING], compiler{COMPILER})
{
    MOV [r], DX
    file{FILE_DRIVE} = r;
    file{FILE_PARTITION} = r >> 8;

    print("Hello, World!\r\n");

    if (!openat(NULL, "/adam/eve.kc", file, FALSE))
    {
        print("Could not open /adam/eve.kc\r\n");
        JMP .hlt
    }
    r = malloc(file[FILE_SIZE]);
    if (!r)
    {
        format(print, "Could not allocate %x bytes of memory\r\n", file[FILE_SIZE]);
        JMP .hlt
    }
    if (!read(file, file[FILE_SIZE], r))
    {
        print("Could not read /adam/eve.kc\r\n");
        JMP .hlt
    }

    s[STRINGPTR] = r;
    s[STRINGLEN] = file[FILE_SIZE];
    if (!compiler_init(compiler))
    {
        print("Could not initialize compiler\r\n");
        JMP .hlt
    }

    eve = compile(compiler, s);
    free(r);
    if (!eve)
    {
        print("Could not compile /adam/eve.kc\r\n");
        JMP .hlt
    }

    JMP [eve]
.hlt:
    HLT
    JMP .hlt
}

switch_unreal:
    CLI

    JMP 0x18:.bit16
.bit16:
USE16
    MOV AX, 0x10
    MOV DS, AX
    MOV ES, AX
    MOV SS, AX
    MOV FS, AX
    MOV GS, AX
    MOV EAX, CR0
    AND AL, 0xFE
    MOV CR0, EAX
    JMP 0x00:.unreal
.unreal:
    XOR AX, AX
    MOV DS, AX
    MOV ES, AX
    MOV SS, AX
    MOV FS, AX
    MOV GS, AX
    JMP ESI

switch_protected:
    CLI

    LGDT [gdtr]

    MOV EAX, CR0
    OR AL, 1
    MOV CR0, EAX
    JMP 0x08:.protected
.protected:
USE32
    MOV AX, 0x10
    MOV DS, AX
    MOV ES, AX
    MOV SS, AX
    MOV FS, AX
    MOV GS, AX
    JMP ESI

# FIXME: this probably gives trouble if ESP is bigger than 64K
function interrupt(int, eax, ecx, edx, ebx, esi, edi)
{
    MOV ESI, .unreal
    JMP switch_unreal
USE16
.unreal:
    MOV AL, [int]
    MOV [.int + 1], AL
    MOV EAX, [eax]
    MOV ECX, [ecx]
    MOV EDX, [edx]
    MOV EBX, [ebx]
    MOV ESI, [esi]
    MOV EDI, [edi]
    STI
.int:
    INT 0x00
    SETB [int]
    MOV ESI, .protected
    JMP switch_protected
USE32
.protected:
    return ~int;
}

gdtr:
    DW .end - .gdt - 1
    DD .gdt
.gdt:
    DD 0, 0
    DB 0xFF, 0xFF, 0, 0, 0, 0x9A, 0xCF, 0
    DB 0xFF, 0xFF, 0, 0, 0, 0x92, 0xCF, 0
    DB 0xFF, 0xFF, 0, 0, 0, 0x9A, 0x00, 0
.end:

function print(s)
(i)
{
    i = 0;
    while (i <! s[STRINGLEN])
    {
        interrupt(0x10, 0x0E00 | s[STRINGPTR]{i});
        i += 1;
    }
}

function lba_do(ax, dl, sectors, lba)
{
    MOV AX, [sectors]
    MOV [dap_sectors], AX
    MOV EAX, [lba]
    MOV [dap_lba], EAX
    return interrupt(0x13, ax, 0, dl, 0, dap);
}

function lba_write(dl, sectors, lba, buf)
{
    memcpy(DISK_BUF, buf, sectors *! 512);
    return lba_do(0x4300, dl, sectors, lba);
}

function lba_read(dl, sectors, lba, buf)
{
    if (!lba_do(0x4200, dl, sectors, lba)) return FALSE;
    memcpy(buf, DISK_BUF, sectors *! 512);
    return TRUE;
}

dap:
    DB 16
    DB 0
dap_sectors:
    DW 0
dap_buffer:
    DW DISK_BUF %! 16
    DW DISK_BUF /! 16
dap_lba:
    DD 0
    DD 0

include "lib/def.kc"
include "lib/util.kc"
include "lib/fs.kc"
include "lib/malloc.kc"
include "compiler/compiler.kc"