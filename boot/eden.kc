ORG 0x500
USE16

const STACK = $! + 48 *! 1024;
const DISK_BUF = STACK;

IN AL, 0x92
OR AL, 2
OUT 0x92, AL

MOV ESI, pmode
JMP switch_protected

USE32
pmode:
    MOV ESP, STACK

function pmodef()
(file{FILE})
{
    print("Hello, World!\r\n\r\nSo many switches!\r\n");
    format(print, "Cool!\r\n");
    format(print, "Look, a number %x!\r\n", 0xBEEFBABE);
    openat(NULL, ":80;0/", file, FALSE);
    format(print, "opened root at drive %x partition %x\r\n", file{FILE_DRIVE}, file{FILE_PARTITION});
.hlt:
    HLT
    JMP .hlt
}

switch_unreal:
    CLI

    JMP 0x18:.bit16
.bit16:
USE16
    MOV AX, 0x10
    MOV DS, AX
    MOV ES, AX
    MOV SS, AX
    MOV FS, AX
    MOV GS, AX
    MOV EAX, CR0
    AND AL, 0xFE
    MOV CR0, EAX
    JMP 0x00:.unreal
.unreal:
    XOR AX, AX
    MOV DS, AX
    MOV ES, AX
    MOV SS, AX
    MOV FS, AX
    MOV GS, AX
    JMP ESI

switch_protected:
    CLI

    LGDT [gdtr]

    MOV EAX, CR0
    OR AL, 1
    MOV CR0, EAX
    JMP 0x08:.protected
.protected:
USE32
    MOV AX, 0x10
    MOV DS, AX
    MOV ES, AX
    MOV SS, AX
    MOV FS, AX
    MOV GS, AX
    JMP ESI

# FIXME: this probably gives trouble if ESP is bigger than 64K
# also return carry flag to see if success/failure
function interrupt(int, eax, ecx, edx, ebx, esi, edi)
{
    MOV ESI, .unreal
    JMP switch_unreal
USE16
.unreal:
    MOV AL, [int]
    MOV [.int + 1], AL
    MOV EAX, [eax]
    MOV ECX, [ecx]
    MOV EDX, [edx]
    MOV EBX, [ebx]
    MOV ESI, [esi]
    MOV EDI, [edi]
    STI
.int:
    INT 0x00
    MOV ESI, .protected
    JMP switch_protected
USE32
.protected:
}

gdtr:
    DW .end - .gdt - 1
    DD .gdt
.gdt:
    DD 0, 0
    DB 0xFF, 0xFF, 0, 0, 0, 0x9A, 0xCF, 0
    DB 0xFF, 0xFF, 0, 0, 0, 0x92, 0xCF, 0
    DB 0xFF, 0xFF, 0, 0, 0, 0x9A, 0x00, 0
.end:

function print(s)
(i)
{
    i = 0;
    while (i <! s[STRINGLEN])
    {
        interrupt(0x10, 0x0E00 | s[STRINGPTR]{i});
        i += 1;
    }
}

function lba_do(ah, dl, sectors, lbalo, lbahi)
{
    MOV AX, [sectors]
    MOV [dap_sectors], AX
    MOV EAX, [lbalo]
    MOV [dap_lba], EAX
    MOV EAX, [lbahi]
    MOV [dap_lba + 4], EAX
    return interrupt(0x13, ah, 0, dl, 0, dap);
}

function lba_write(dl, sectors, lbalo, lbahi, buf)
{
    memcpy(DISK_BUF, buf, sectors *! 512);
    return lba_do(0x4300, dl, sectors, lbalo, lbahi);
}

function lba_read(dl, sectors, lbalo, lbahi, buf)
{
    if (!lba_do(0x4200, dl, sectors, lbalo, lbahi)) return FALSE;
    memcpy(buf, DISK_BUF, sectors *! 512);
    return TRUE;
}

dap:
    DB 16
    DB 0
dap_sectors:
    DW 0
dap_buffer:
    DW DISK_BUF %! 16
    DW DISK_BUF /! 16
dap_lba:
    DD 0
    DD 0

include "lib/def.kc"
include "lib/util.kc"
include "lib/fs.kc"