struct MAP = [MAP_ENTRIES], [MAP_LEN], [MAP_SIZE], [MAP_KEY_SIZE], [MAP_ENTRY_SIZE], [MAP_COMPARE], [MAP_HASH], [MAP_FREE];

# make this an ordered map by adding MAP_FIRST and MAP_LAST and MAP_ENTRY_NEXT

function map_init(m, size, key_size, value_size, compare, hash, free)
{
    m.[MAP_COMPARE] = compare;
    m.[MAP_HASH] = hash;
    m.[MAP_FREE] = free;
    m.[MAP_LEN] = 0;
    m.[MAP_SIZE] = size;
    m.[MAP_KEY_SIZE] = key_size;
    m.[MAP_ENTRY_SIZE] = key_size + value_size + 1;
    m.[MAP_ENTRIES] = malloc(m.[MAP_ENTRY_SIZE] *! size);
    if (!m.[MAP_ENTRIES]) return FALSE;
    memset(m.[MAP_ENTRIES], 0, m.[MAP_ENTRY_SIZE] *! size);
    return TRUE;
}

function map_free2(m)
(i)
{
    m.[MAP_LEN] = 0;
    i = 0;
    while (i <! m.[MAP_SIZE])
    {
        m.[MAP_ENTRIES]{i *! m.[MAP_ENTRY_SIZE]} = 0;
        if (m.[MAP_FREE]) m.[MAP_FREE](&m.[MAP_ENTRIES]{i *! m.[MAP_ENTRY_SIZE] + 1});
        i += 1;
    }
}

function map_free(m)
{
    map_free2(m);
    free(m.[MAP_ENTRIES]);
}

function hash_string(s)
(hash, i)
{
    hash = 2166136261;
    i = 0;
    while (i <! s.[STRINGLEN])
    {
        hash ^= s.[STRINGPTR]{i};
        hash *!= 16777619;
        i += 1;
    }
    return hash;
}

function map_iter(m, state)
{
    while (*state <! m.[MAP_SIZE] and !m.[MAP_ENTRIES]{*state *! m[MAP_ENTRY_SIZE]}) *state += 1;

    if (*state >=! m.[MAP_SIZE]) return NULL;

    *state += 1;
    return &m.[MAP_ENTRIES]{(*state - 1) *! m.[MAP_ENTRY_SIZE] + 1};
}

function map_ref(m, key, index)
(hash, i, e)
{
    hash = m.[MAP_HASH](key);
    i = hash & (m.[MAP_SIZE] - 1);

    while (m.[MAP_ENTRIES]{i *! m.[MAP_ENTRY_SIZE]})
    {
        e = &m.[MAP_ENTRIES]{i *! m.[MAP_ENTRY_SIZE] + 1};
        if (m.[MAP_COMPARE](key, e)) return e;
        i += 1;
        if (i >=! m.[MAP_SIZE]) i = 0;
    }

    if (index) *index = i;
    return NULL;
}

function map_get(m, key, value)
(e)
{
    e = map_ref(m, key, NULL);
    if (!e) return FALSE;
    memcpy(value, e + m.[MAP_KEY_SIZE], m.[MAP_ENTRY_SIZE] - 1 - m.[MAP_KEY_SIZE]);
    return TRUE;
}

function map_expand(m)
(old_entries, old_size, i)
{
    old_entries = m.[MAP_ENTRIES];
    old_size = m.[MAP_SIZE];
    m.[MAP_SIZE] *!= 2;
    m.[MAP_ENTRIES] = malloc(m.[MAP_SIZE] *! m.[MAP_ENTRY_SIZE]);
    if (!m.[MAP_ENTRIES]) return FALSE;
    memset(m.[MAP_ENTRIES], 0, m.[MAP_SIZE] *! m.[MAP_ENTRY_SIZE]);

    i = 0;
    while (i <! old_size)
    {
        if (!old_entries{i *! m.[MAP_ENTRY_SIZE]}) continue;
        map_set(m, &old_entries{i *! m.[MAP_ENTRY_SIZE] + 1}, &old_entries{i *! m.[MAP_ENTRY_SIZE] + 1 + m.[MAP_KEY_SIZE]});
    }

    free(old_entries);
    return TRUE;
}

function map_set(m, key, value)
(entry, i)
{
    if (m.[MAP_LEN] >=! m.[MAP_SIZE] /! 2)
    {
        if (!map_expand(m)) return FALSE;
    }

    entry = map_ref(m, key, &i);
    if (!entry)
    {
        entry = &m.[MAP_ENTRIES]{i *! m.[MAP_ENTRY_SIZE] + 1};
        entry{-1} = 1;
        m.[MAP_LEN] += 1;
        memcpy(entry, key, m.[MAP_KEY_SIZE]);
    }

    memcpy(entry + m.[MAP_KEY_SIZE], value, m.[MAP_ENTRY_SIZE] - m.[MAP_KEY_SIZE] - 1);

    return TRUE;
}