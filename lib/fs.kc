struct {FAT_BS} = 3{BS_BOOTJMP}, 8{BS_OEM_NAME}, .<BS_BYTES_PER_SECTOR>, {BS_SECTORS_PER_CLUSTER}, .<BS_RESERVED_SECTOR_COUNT>, {BS_TABLE_COUNT}, .<BS_ROOT_ENTRY_COUNT>, .<BS_TOTAL_SECTORS_16>, {BS_MEDIA_TYPE}, .<BS_TABLE_SIZE_16>, .<BS_SECTORS_PER_TRACK>, .<BS_HEAD_SIDE_COUNT>, .[BS_HIDDEN_SECTOR_COUNT], .[BS_TOTAL_SECTORS_32], .[BS_TABLE_SIZE_32], .<BS_EXTENDED_FLAGS>, .<BS_FAT_VERSION>, .[BS_ROOT_CLUSTER], .<BS_FAT_INFO>, .<BS_BACKUP_BS_SECTOR>, 12{BS_RESERVED}, {BS_DRIVE_NUMBER}, {BS_RESERVED2}, {BS_BOOT_SIGNATURE}, [BS_VOLUME_ID], 11{BS_VOLUME_LABEL}, 8{BS_FAT_TYPE_LABEL};

const PARTITION_TABLE = 0x1BE;
struct {PARTITION} = {PARTITION_ATTRIBUTES}, 3{PARTITION_CHS}, {PARTITION_TYPE}, 3{PARTITION_CHS_END}, .[PARTITION_LBA], .[PARTITION_LBA_SECTORS];

struct {FILE} = 512{FILE_BUF}, {FILE_DRIVE}, {FILE_PARTITION}, {FILE_SECTORS_PER_CLUSTER}, [FILE_DATA_SECTOR], [FILE_CLUSTER_CUR], [FILE_SEEK], [FILE_SIZE];

struct {DIR_ENTRY} = 11{DIR_ENTRY_83NAME}, {DIR_ENTRY_ATTR}, {DIR_ENTRY_RESERVED}, {DIR_ENTRY_CREATE_HUNDRETHS}, <DIR_ENTRY_CREATE_TIME>, <DIR_ENTRY_CREATE_DATE>, <DIR_ENTRY_ACCESSED_DATE>, <DIR_ENTRY_CLUSTER_HI>, <DIR_ENTRY_MODIFICATION_TIME>, <DIR_ENTRY_MODIFICATION_DATE>, <DIR_ENTRY_CLUSTER_LO>, [DIR_ENTRY_FILE_SIZE];

function openat(cwd, path, file, create)
(s[STRING], d{DIR_ENTRY}, state, end, read)
{
    if (cwd) memcpy(file, cwd, FILE);

    state = 0;
    read = FALSE;
    while (strtok(path, '/', s, &state))
    {
        if (s[STRINGPTR]{0} == ':')
        {
            s[STRINGPTR] += 1;
            file{FILE_DRIVE} = hex2int(s, &end);
            s[STRINGPTR] += end;
            s[STRINGLEN] -= end + 1;
        }
        if (s[STRINGPTR]{0} == ';')
        {
            s[STRINGPTR] += 1;
            file{FILE_PARTITION} = hex2int(s, &end);
            s[STRINGPTR] += end;
            s[STRINGLEN] -= end + 1;
        }

        if (!read and s[STRINGLEN] == 0)
        {
            if (!lba_read(file{FILE_DRIVE}, 1, 0, file)) return FALSE;
            if (!lba_read(file{FILE_DRIVE}, 1, file.[PARTITION_TABLE + file{FILE_PARTITION} *! 16 + PARTITION_LBA], file)) return FALSE;

            file{FILE_SECTORS_PER_CLUSTER} = file{BS_SECTORS_PER_CLUSTER};
            file[FILE_DATA_SECTOR] = file.<BS_RESERVED_SECTOR_COUNT> + file.[BS_HIDDEN_SECTOR_COUNT] + file{BS_TABLE_COUNT} *! file.[BS_TABLE_SIZE_32];
            file[FILE_CLUSTER_CUR] = file.[BS_ROOT_CLUSTER];
            file[FILE_SEEK] = 0;
            read = TRUE;
        }
        else if (s[STRINGLEN] >! 0 and !strcmp(s, "."))
        {
            while (dir_next(file, d))
            {
                if (fnamecmp(s, d))
                {
                    file[FILE_SIZE] = d[DIR_ENTRY_FILE_SIZE];
                    file[FILE_CLUSTER_CUR] = d<DIR_ENTRY_CLUSTER_HI> << 16 | d<DIR_ENTRY_CLUSTER_LO>;
                    file[FILE_SEEK] = 0;
                    JMP .e
                }
            }
            return FALSE;
        }
.e:
    }

    return TRUE;
}

function name2f83(s, o83)
(x)
{
    memset(o83, ' ', 11);
    if (s[STRINGPTR]{0} == '.') return memcpy(o83, s[STRINGPTR], s[STRINGLEN]);

    x = strchr(s, '.');
    memcpy(o83, s[STRINGPTR], x);
    if (x == s[STRINGLEN]) return;
    memcpy(o83 + 8, s[STRINGPTR] + x + 1, s[STRINGLEN] - x - 1);
}

function fnamecmp(s, d83)
(f83{11})
{
    name2f83(s, f83);
    return memicmp(f83, d83, 11);
}

function dir_next(file, outentry)
{
.again:
    if (!read(file, 32, outentry)) return FALSE;
    if (outentry{0} == 0) return FALSE;
    if (outentry{0} == 0xE5) JMP .again
    if (outentry{11} == 0x0F) JMP .again
    return TRUE;
}

function cur_sector(file)
{
    return cluster2sector(file, file[FILE_CLUSTER_CUR]) + (file[FILE_SEEK] & 2047) /! 512;
}

function read(file, n, buf)
(sectors_read, x)
{
    while (n)
    {
        if (file[FILE_SEEK] & 511 == 0)
        {
            if (n >! 512)
            {
                sectors_read = minu(n /! 512, (file{FILE_SECTORS_PER_CLUSTER} - file[FILE_SEEK] %! file{FILE_SECTORS_PER_CLUSTER}) /! 512);
                if (!lba_read(file{FILE_DRIVE}, sectors_read, cur_sector(file), buf)) return FALSE;
                x = sectors_read *! 512;
                file[FILE_SEEK] += x;
                n -= x;
                buf += x;
            }
            else
            {
                if (!lba_read(file{FILE_DRIVE}, 1, cur_sector(file), file)) return FALSE;
                memcpy(buf, file, n);
                file[FILE_SEEK] += n;
                return TRUE;
            }
        }
        else
        {
            x = minu(n, 512 - (file[FILE_SEEK] & 511));
            memcpy(buf, file + (file[FILE_SEEK] & 511), x);
            file[FILE_SEEK] += x;
            n -= x;
            buf += x;
        }
    }

    return TRUE;
}

function cluster2sector(file, cluster) return ((cluster - 2) *! file{FILE_SECTORS_PER_CLUSTER}) + file[FILE_DATA_SECTOR];