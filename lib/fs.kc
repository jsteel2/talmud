import "/lib/disk.kc"
import "/lib/util.kc"

struct FILES = FILE_DRIVE, FILE_PARTITION, FILE_DATA_SECTOR, FILE_SECTORS_PER_CLUSTER, FILE_LBA_START, FILE_LBA_CUR, FILE_CLUSTER_CUR, FILE_FAT_SECTOR, FILE_DIR_OFF, FILE_SEEK, FILE_SIZE;
const FILEDATA = FILES *! 2;
const FILEDATASIZE = 512;
const FILE = FILEDATASIZE + FILES *! 2;

const FAT_BYTES_PER_SECTOR = FILEDATA + 0x0B;
const FAT_SECTORS_PER_CLUSTER = FILEDATA + 0x0D;
const FAT_RESERVED_SECTORS = FILEDATA + 0x0E;
const FAT_FATS = FILEDATA + 0x10;
const FAT_ROOT_ENTRIES = FILEDATA + 0x11;
const FAT_SECTORS_PER_FAT = FILEDATA + 0x16;
const FAT_HIDDEN_SECTORS = FILEDATA + 0x1C;

const FAT_DIR_CLUSTER = FILEDATA + 26;
const FAT_DIR_ATTR = FILEDATA + 11;
const FAT_DIR_SIZE = FILEDATA + 28;

function exec(file, argc, argv, cwdpat)
(old, seg, nargv, sp, i, ncwdpat, bb)
{
    MOV AX, DS
    MOV [seg], AX
    MOV [old], AX
    seg = seg + 0x1000;
    if (read(file, -2, 0, seg) = -1) return 0;
    MOV DI, [argc]
    SHL DI, 1
    SHL DI, 1
    NEG DI
    MOV [nargv], DI
    sp = nargv;
    i = argc;
    while (i)
    {
        i = i - 1;
        sp = sp - argv[i *! STRING + STRINGLEN];
        memcpy(sp, argv[i *! STRING + STRINGPTR], argv[i *! STRING + STRINGLEN], seg);
        argv[i *! STRING + STRINGPTR] = sp;
    }
    memcpy(nargv, argv, argc *! 4, seg);
    ncwdpat = sp - cwdpat[STRINGLEN] - STRING *! 2;
    bb = cwdpat[STRINGPTR];
    cwdpat[STRINGPTR] = sp - cwdpat[STRINGLEN];
    sp = ncwdpat;
    memcpy(ncwdpat, cwdpat, STRING *! 2, seg);
    cwdpat[STRINGPTR] = bb;
    memcpy(ncwdpat + STRING *! 2, cwdpat[STRINGPTR], cwdpat[STRINGLEN], seg);
    MOV SI, [argc]
    MOV DI, [nargv]
    MOV AX, [ncwdpat]
    MOV BX, BP
    MOV CX, [old]
    MOV DX, [seg]
    MOV ES, DX
    MOV DS, DX
    CLI
    MOV SP, [sp]
    MOV SS, DX
    STI
    PUSH ES
    MOV DX, 0
    PUSH DX
    MOV BP, SP
    PUSH BX
    PUSH CX
    CALL FAR [BP]
    POP CX
    POP BX
    POP DX
    POP DX
    MOV DS, CX
    MOV ES, CX
    CLI
    MOV SS, CX
    MOV SP, BX
    STI
    MOV BP, BX
    return 1;
}

function read(file, n, buf, seg)
(i, x)
{
    i = 0;
    # rename fILE_DIR_OFF to something more general and fitting
    if (file[FILE_DIR_OFF] <$ 0) file[FILE_DIR_OFF] = 0;
    n = minu(n, file[FILE_SIZE]);
    while (n and file[FILE_SEEK] <! file[FILE_SIZE])
    {
        if (file[FILE_SEEK] %! (file[FILE_SECTORS_PER_CLUSTER] *! 512) = 0 and file[FILE_SEEK] != 0)
        {
            if (!sector_read(file[FILE_DRIVE], file[FILE_FAT_SECTOR] + (file[FILE_CLUSTER_CUR] *! 2 /! 512), 1, file + FILEDATA)) return -1;
            file[FILE_CLUSTER_CUR] = *(file + FILEDATA + file[FILE_CLUSTER_CUR] *! 2 %! 512);
            file[FILE_DIR_OFF] = 0;
            file[FILE_LBA_CUR] = ((file[FILE_CLUSTER_CUR] - 2) *! file[FILE_SECTORS_PER_CLUSTER]) + file[FILE_DATA_SECTOR];
            if (file[FILE_CLUSTER_CUR] >=! 0xFFF8) return i;
            if (!sector_read(file[FILE_DRIVE], file[FILE_LBA_CUR], 1, file + FILEDATA)) return -1;
        }
        if (file[FILE_DIR_OFF] >=! FILEDATASIZE)
        {
            file[FILE_DIR_OFF] = 0;
            file[FILE_LBA_CUR] = file[FILE_LBA_CUR] + 1;
            if (!sector_read(file[FILE_DRIVE], file[FILE_LBA_CUR], 1, file + FILEDATA)) return -1;
        }
        x = minu(minu(n, file[FILE_SIZE] - file[FILE_SEEK]), FILEDATASIZE - file[FILE_DIR_OFF]);
        memcpy(buf + i, file + FILEDATA + file[FILE_DIR_OFF], x, seg);
        i = i + x;
        n = minu(n - x, file[FILE_SIZE] - file[FILE_SEEK]);
        file[FILE_SEEK] = file[FILE_SEEK] + x;
        file[FILE_DIR_OFF] = file[FILE_DIR_OFF] + x;
    }
    return i;
}

function dir_next(file, out)
{
.again:
    file[FILE_DIR_OFF] = file[FILE_DIR_OFF] + 32;
    if (file[FILE_DIR_OFF] >=! FILEDATASIZE)
    {
        file[FILE_DIR_OFF] = 0;
        file[FILE_LBA_CUR] = file[FILE_LBA_CUR] + 1;
        sector_read(file[FILE_DRIVE], file[FILE_LBA_CUR], 1, file + FILEDATA);
    }
    if (*(file + FILEDATA + file[FILE_DIR_OFF]) = 0) return 0;
    if (*(file + file[FILE_DIR_OFF] + FAT_DIR_ATTR) = 0x0F) JMP .again
    out[STRINGLEN] = 11;
    out[STRINGPTR] = file + FILEDATA + file[FILE_DIR_OFF];
    return 1;
}

function openat(cwd, path, file)
(s[STRING], d[STRING], state, old, end, drive, partition, root_read)
{
    file[FILE_DIR_OFF] = -32;
    state = 0;
    old = state;
    root_read = 0;
    if (cwd)
    {
        memcpy(file, cwd, FILE, -1);
    }
    drive = file[FILE_DRIVE];
    partition = file[FILE_PARTITION];
    while (strtok(path, '/', s, &state))
    {
        if (s[STRINGPTR]{0} = ':')
        {
            s[STRINGPTR] = s[STRINGPTR] + 1;
            file[FILE_DRIVE] = atoi(s, &end);
            drive = file[FILE_DRIVE];
            state = old + end + 1;
            JMP .c
        }
        if (s[STRINGPTR]{0} = ';')
        {
            s[STRINGPTR] = s[STRINGPTR] + 1;
            file[FILE_PARTITION] = atoi(s, &end);
            partition = file[FILE_PARTITION];
            state = old + end + 1;
            JMP .c
        }

        if (s[STRINGLEN] = 0 and !root_read)
        {
            sector_read(drive, 0, 1, file + FILEDATA);
            sector_read(drive, *(file + FILEDATA + 0x1BE + partition *! 16 + 8), 1, file + FILEDATA);
            file[FILE_FAT_SECTOR] = *(file + FAT_RESERVED_SECTORS) + *(file + FAT_HIDDEN_SECTORS);
            file[FILE_LBA_CUR] = *(file + FAT_RESERVED_SECTORS) + *(file + FAT_HIDDEN_SECTORS) + file{FAT_FATS} *! *(file + FAT_SECTORS_PER_FAT);
            file[FILE_LBA_START] = file[FILE_LBA_CUR];
            file[FILE_SECTORS_PER_CLUSTER] = file{FAT_SECTORS_PER_CLUSTER};
            file[FILE_DATA_SECTOR] = *(file + FAT_RESERVED_SECTORS) + *(file + FAT_HIDDEN_SECTORS) + file{FAT_FATS} *! *(file + FAT_SECTORS_PER_FAT) + ((*(file + FAT_ROOT_ENTRIES) *! 32) + (*(file + FAT_BYTES_PER_SECTOR) - 1)) /! *(file + FAT_BYTES_PER_SECTOR);
            sector_read(drive, file[FILE_LBA_CUR], 1, file + FILEDATA);
            root_read = 1;
            file[FILE_DIR_OFF] = -32;
        }
        else if (!strcmp(s, ".") and s[STRINGLEN] >! 0)
        {
            root_read = 1;
            while (dir_next(file, d))
            {
                if (fnamecmp(s, d))
                {
                    file[FILE_CLUSTER_CUR] = *(file + file[FILE_DIR_OFF] + FAT_DIR_CLUSTER);
                    if (file[FILE_CLUSTER_CUR] = 0)
                    {
                        sector_read(drive, 0, 1, file + FILEDATA);
                        sector_read(drive, *(file + FILEDATA + 0x1BE + partition *! 16 + 8), 1, file + FILEDATA);
                        file[FILE_FAT_SECTOR] = *(file + FAT_RESERVED_SECTORS) + *(file + FAT_HIDDEN_SECTORS);
                        file[FILE_LBA_CUR] = *(file + FAT_RESERVED_SECTORS) + *(file + FAT_HIDDEN_SECTORS) + file{FAT_FATS} *! *(file + FAT_SECTORS_PER_FAT);
                        file[FILE_LBA_START] = file[FILE_LBA_CUR];
                        file[FILE_SECTORS_PER_CLUSTER] = file{FAT_SECTORS_PER_CLUSTER};
                        file[FILE_DATA_SECTOR] = *(file + FAT_RESERVED_SECTORS) + *(file + FAT_HIDDEN_SECTORS) + file{FAT_FATS} *! *(file + FAT_SECTORS_PER_FAT) + ((*(file + FAT_ROOT_ENTRIES) *! 32) + (*(file + FAT_BYTES_PER_SECTOR) - 1)) /! *(file + FAT_BYTES_PER_SECTOR);
                        sector_read(drive, file[FILE_LBA_CUR], 1, file + FILEDATA);
                        file[FILE_DIR_OFF] = -32;
                    }
                    else
                    {
                        file[FILE_LBA_CUR] = ((file[FILE_CLUSTER_CUR] - 2) *! file[FILE_SECTORS_PER_CLUSTER]) + file[FILE_DATA_SECTOR];
                        file[FILE_LBA_START] = file[FILE_LBA_CUR];
                        file[FILE_SIZE] = *(file + file[FILE_DIR_OFF] + FAT_DIR_SIZE);
                        sector_read(drive, file[FILE_LBA_CUR], 1, file + FILEDATA);
                        file[FILE_DIR_OFF] = -32;
                        file[FILE_SEEK] = 0;
                    }
                    JMP .c
                }
            }
            return 0;
        }
.c:
        old = state;
    }
    return 1;
}

function fnamecmp(s1, s2)
(i, i2, l, c1, c2)
{
    if (s1[STRINGPTR]{0} = '.')
    {
        if (s2[STRINGPTR]{0} != '.') return 0;
        if (s1[STRINGLEN] = 2 and s2[STRINGPTR]{1} = '.') return 1;
        return s1[STRINGLEN] = 1;
    }
    i = 0;
    i2 = 0;
    while (i <! 11)
    {
        c1 = upper(i2 >=! s1[STRINGLEN] ? ' ' : s1[STRINGPTR]{i2});
        if (c1 = '.')
        {
            if (i <! 7) i = 7;
            c1 = ' ';
        }
        c2 = upper(s2[STRINGPTR]{i});
        if (c1 != c2) return 0;
        i = i + 1;
        i2 = i2 + 1;
    }
    return 1;
}

function path_append(base, app)
(s[STRING], state)
{
    state = 0;
    if (app[STRINGPTR]{0} = ':' or app[STRINGPTR]{0} = ';' or app[STRINGPTR]{0} = '/')
    {
        memcpy(base[STRINGPTR] + strchr(base, app[STRINGPTR]{0}), app[STRINGPTR], strchr(app, '/') - strchr(app, app[STRINGPTR]{0}), -1);
        state = strchr(app, '/') + 1;
        base[STRINGLEN] = strchr(base, '/') + 1;
    }

    while (strtok(app, '/', s, &state))
    {
        if (s[STRINGLEN] = 0 or strcmp(s, ".")) JMP .c
        if (strcmp(s, ".."))
        {
            if (base[STRINGPTR]{base[STRINGLEN] - 1} = '/') base[STRINGLEN] = base[STRINGLEN] - 1;
            base[STRINGLEN] = strrchr(base, '/') + 1;
            JMP .c
        }

        if (base[STRINGPTR]{base[STRINGLEN] - 1} != '/')
        {
            base[STRINGPTR]{base[STRINGLEN]} = '/';
            base[STRINGLEN] = base[STRINGLEN] + 1;
        }
        memcpy(base[STRINGPTR] + base[STRINGLEN], s[STRINGPTR], s[STRINGLEN], -1);
        base[STRINGLEN] = base[STRINGLEN] + s[STRINGLEN];
.c:
    }
}
