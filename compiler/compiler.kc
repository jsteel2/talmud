include "compiler/tokenizer.kc"

struct COMPILER = TOKENIZER{CTOK}, MAP{CIDENTS}, TOKEN{CCUR}, TOKEN{CNEXT}, [CBIN], [CEXCEPT], [CCUR_FILE], [CIS_FIRST_PASS], [CIS_CONST_EXPR];
struct COMPILER_IDENT = [COMPILER_IDENT_ADDR];

function compiler_init(c)
{
    c.[CEXCEPT] = 0;
    c.[CCUR_FILE] = "None";
    if (!map_init(&c{CIDENTS}, 1024, STRING, COMPILER_IDENT, strcmp, hash_string, NULL)) return FALSE;
    return TRUE;
}

function compiler_throw(c, file, line)
{
    if (file) format(print, ", compiler died at %s(%u) in file \"%s\", line %u, column %u\n", file, line, c.[CCUR_FILE], c.[CTOK + TLINE], c.[CTOK + TCOL]);

    if (!c.[CEXCEPT]) return FALSE;

    MOV EDI, [c]
    MOV ESP, [EDI + CEXCEPT]
    POP EAX
    POP [EDI + CEXCEPT]
    POP EBP
    JMP EAX
}

compiler_try:
    POP EAX # return address
    POP EDI # compiler
    POP EBX # label
    PUSH EBP
    PUSH [EDI + CEXCEPT]
    PUSH EBX
    MOV [EDI + CEXCEPT], ESP
    SUB ESP, 8
    JMP EAX

compiler_try_end:
    POP EAX # return address
    POP EDI # compiler
    MOV ESP, [EDI + CEXCEPT]
    POP EBX
    POP [EDI + CEXCEPT]
    JMP EAX

function compiler_throw_token(c, file, line, token, expected)
(s{STRING}, buf{10}, sp)
{
    s.[STRINGPTR] = buf;
    if (c.[token + TOKEN_TYPE] == TNUM) sp = int2str(s, c.[token + TOKEN_VALUE], 10, FALSE);
    else sp = &c{token + TOKEN_VALUE};
    format(print, "Unexpected token %u(\"%s\")", c.[token + TOKEN_TYPE], sp);
    if (expected) sp = int2str(s, expected, 10, FALSE);
    else sp = "Unknown";
    return compiler_throw(c, file, line, format(print, " expected type %s", sp));
}

function compiler_advance(c)
{
    memcpy(&c{CCUR}, &c{CNEXT}, TOKEN);
    if (c.[CCUR + TOKEN_TYPE] == TEND) return compiler_throw(c, $@, $*, print("Unexpected EOF"));
    if (!tokenizer_token(&c{CTOK}, &c{CNEXT})) return compiler_throw(c, $@, $*);
    return c.[CCUR + TOKEN_TYPE];
}

function compiler_peek(c)
{
    return c.[CNEXT + TOKEN_TYPE];
}

function compiler_end(c)
{
    return compiler_peek(c) == TEND;
}

function compiler_match(c, t)
{
    return compiler_peek(c) == t ? compiler_advance(c) : FALSE;
}

function compiler_matches(c, t_start, t_end)
{
    return compiler_peek(c) >=! t_start and compiler_peek(c) <=! t_end ? compiler_advance(c) : FALSE;
}

function compiler_consume(c, t)
{
    return compiler_match(c, t) ? TRUE : compiler_throw_token(c, $@, $*, CNEXT, t);
}

function compiler_pass(c, src, is_first_pass)
{
    c.[CIS_FIRST_PASS] = is_first_pass;
    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);

    while (!compiler_end(c)) compiler_statement(c);
}

function compile(c, filename, src)
{
    compiler_try(c, .catch);
    c.[CCUR_FILE] = filename;

    compiler_pass(c, src, TRUE);
    compiler_pass(c, src, FALSE);

    compiler_try_end(c);
.catch:
    if ((c.[CCUR + TOKEN_TYPE] == TSTRING or c.[CCUR + TOKEN_TYPE] == TCHARS) and c.[CCUR + TOKEN_VALUE + STRINGPTR]) free(c.[CCUR + TOKEN_VALUE + STRINGPTR]);
    if ((c.[CNEXT + TOKEN_TYPE] == TSTRING or c.[CNEXT + TOKEN_TYPE] == TCHARS) and c.[CNEXT + TOKEN_VALUE + STRINGPTR]) free(c.[CNEXT + TOKEN_VALUE + STRINGPTR]);
    return NULL;
}

function compiler_statement(c)
{
    switch (compiler_peek(c))
    {
        case TWHILE: return compiler_while(c);
        case TLEFTBRACE: return compiler_statements(c);
        case TINCLUDE: return compiler_include(c);
        case TCONST: return compiler_const(c);
        case TSTRUCT: return compiler_struct(c);
        default: compiler_expression(c); return compiler_consume(c, TSEMICOLON);
    }
}

function compiler_statements(c)
{
    compiler_consume(c, TLEFTBRACE);
    while (!compiler_match(c, TRIGHTBRACE)) compiler_statement(c);
}

function compiler_struct(c)
{
    compiler_consume(c, TSTRUCT);
    compiler_consume(c, TIDENT);
    compiler_consume(c, TEQUALS);
    do
    {
        compiler_consume(c, TLEFTBRACKET);
        compiler_consume(c, TIDENT);
        compiler_consume(c, TRIGHTBRACKET);
    } while (compiler_match(c, TCOMMA));
    compiler_consume(c, TSEMICOLON);
}

function compiler_const(c)
(s{STRING})
{
    compiler_consume(c, TCONST);
    do
    {
        compiler_consume(c, TIDENT);
        memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
        compiler_consume(c, TEQUALS);
        compiler_const_set(c, s, compiler_const_expression(c));
    } while (compiler_match(c, TCOMMA));
    compiler_consume(c, TSEMICOLON);
}

function compiler_include(c)
(f{FILE}, ocur_file, s{STRING}, src{STRING}, otok{TOKENIZER})
{
    compiler_consume(c, TINCLUDE);
    compiler_consume(c, TSTRING);

    ocur_file = c.[CCUR_FILE];
    memcpy(otok, &c{CTOK}, TOKENIZER);

    memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
    c.[CCUR_FILE] = s;

    src.[STRINGPTR] = NULL;
    compiler_try(c, .catch);
    if (!open(s, f, FALSE)) compiler_throw(c, $@, $*, format(print, "Could not open file \"%s\"", s));
    src.[STRINGLEN] = f.[FILE_SIZE];
    src.[STRINGPTR] = malloc(src.[STRINGLEN]);
    if (!src.[STRINGPTR]) compiler_throw(c, $@, $*, format(print, "Failed to allocate %uB of memory\n", src.[STRINGLEN]));

    if (!read(f, src.[STRINGLEN], src.[STRINGPTR])) compiler_throw(c, $@, $*, format(print, "Could not read file \"%s\"", s));

    compiler_pass(c, src, c.[CIS_FIRST_PASS]);
    compiler_try_end(c);

    free(src.[STRINGPTR]);
    free(s.[STRINGPTR]);
    s.[STRINGPTR] = NULL;

    c.[CCUR_FILE] = ocur_file;
    memcpy(&c{CTOK}, otok, TOKENIZER);
    return;

.catch:
    free(src.[STRINGPTR]);
    free(s.[STRINGPTR]);
    s.[STRINGPTR] = NULL;
    compiler_throw(c, NULL, NULL);
}

function compiler_while(c)
{
    compiler_consume(c, TWHILE);
    compiler_consume(c, TLEFTPAREN);
    compiler_expression(c);
    compiler_consume(c, TRIGHTPAREN);

    compiler_statement(c);
}

function compiler_const_expression(c)
(r)
{
    c.[CIS_CONST_EXPR] = TRUE;
    r = compiler_expression(c);
    c.[CIS_CONST_EXPR] = FALSE;
    return r;
}

function compiler_expression(c)
{
    return compiler_primary(c);
}

function compiler_primary(c)
(ident{COMPILER_IDENT})
{
    if (c.[CIS_CONST_EXPR])
    {
        switch (compiler_advance(c))
        {
            case TNUM: return c.[CCUR + TOKEN_VALUE];
            default: return compiler_throw_token(c, $@, $*, CCUR, 0);
        }
    }

    switch (compiler_advance(c))
    {
        case TIDENT:
            if (compiler_global_get(c, &c{CCUR + TOKEN_VALUE}, ident))
            {
                format(print, "MOV EAX, 0x%x\n", ident.[COMPILER_IDENT_ADDR]);
            }
            else if (c.[CIS_FIRST_PASS])
            {
                format(print, "MOV EAX, 0\n");
            }
            else
            {
                compiler_throw(c, $@, $*, format(print, "Undefined identifier %s", &c{CCUR + TOKEN_VALUE}));
            }
            break;
        case TSTRING:
            format(print, "MOV EAX, \"%s\"\n", &c{CCUR + TOKEN_VALUE});
            free(c.[CCUR + TOKEN_VALUE + STRINGPTR]);
            c.[CCUR + TOKEN_VALUE + STRINGPTR] = NULL;
            break;
        case TNUM:
            format(print, "MOV EAX, %u\n", c.[CCUR + TOKEN_VALUE]);
            break;
        default:
            compiler_throw_token(c, $@, $*, CCUR, 0);
            break;
    }

    while (compiler_post(c));
}

function compiler_post(c)
{
    if (!compiler_match(c, TLEFTPAREN)) return FALSE;
    compiler_expression(c);
    compiler_consume(c, TRIGHTPAREN);
    print("CALL\n");
    return TRUE;
}

function compiler_const_set(c, name, address)
{
    if (!map_set(&c{CIDENTS}, name, &address)) return compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", name, address));
    return TRUE;
}

function compiler_global_get(c, name, out)
{
    return map_get(&c{CIDENTS}, name, out);
}