include "compiler/tokenizer.kc"
include "compiler/asm.kc"

struct COMPILER = TOKENIZER{CTOK}, MAP{CIDENTS}, MAP{CSTRINGS}, TOKEN{CCUR}, TOKEN{CNEXT}, VEC{CLATER}, [CLATER_I], [CBIN], [CEXCEPT], [CCUR_FILE], [CIS_FIRST_PASS], [CIS_CONST_EXPR], [CIP], [CORG], [CSTRING_OFFSET], [CPROG_END];
struct COMPILER_IDENT = [COMPILER_IDENT_ADDR];
struct COMPILER_STRING = [COMPILER_STRING_ADDR];

function compiler_init(c)
{
    c.[CEXCEPT] = 0;
    c.[CCUR_FILE] = "None";
    if (!map_init(&c{CIDENTS}, 1024, STRING, COMPILER_IDENT, strcmp, hash_string, free_string)) return FALSE;
    if (!map_init(&c{CSTRINGS}, 1024, STRING, COMPILER_STRING, strcmp, hash_string, free_string)) return FALSE;
    if (!vec_init(&c{CLATER}, 1024, 4)) return FALSE;
    return TRUE;
}

function compiler_free(c)
{
    map_free(&c{CIDENTS});
    map_free(&c{CSTRINGS});
    vec_free(&c{CLATER});
}

function compiler_throw(c, file, line)
{
    if (file) format(print, ", compiler died at %s(%u) in file \"%s\", line %u, column %u\n", file, line, c.[CCUR_FILE], c.[CTOK + TLINE], c.[CTOK + TCOL]);

    if (!c.[CEXCEPT]) return FALSE;

    MOV EDI, [c]
    MOV ESP, [EDI + CEXCEPT]
    POP EAX
    POP [EDI + CEXCEPT]
    POP EBP
    JMP EAX
}

compiler_try:
    POP EAX # return address
    POP EDI # compiler
    POP EBX # label
    PUSH EBP
    PUSH [EDI + CEXCEPT]
    PUSH EBX
    MOV [EDI + CEXCEPT], ESP
    SUB ESP, 8
    JMP EAX

compiler_try_end:
    POP EAX # return address
    POP EDI # compiler
    MOV ESP, [EDI + CEXCEPT]
    POP EBX
    POP [EDI + CEXCEPT]
    JMP EAX

function compiler_throw_token(c, file, line, token, expected)
(s{STRING}, buf{10}, sp)
{
    s.[STRINGPTR] = buf;
    if (c.[token + TOKEN_TYPE] == TNUM) sp = int2str(s, c.[token + TOKEN_VALUE], 10, FALSE);
    else sp = &c{token + TOKEN_VALUE};
    format(print, "Unexpected token %u(\"%s\")", c.[token + TOKEN_TYPE], sp);
    if (expected) sp = int2str(s, expected, 10, FALSE);
    else sp = "Unknown";
    return compiler_throw(c, file, line, format(print, " expected type %s", sp));
}

function compiler_advance(c)
{
    memcpy(&c{CCUR}, &c{CNEXT}, TOKEN);
    if (c.[CCUR + TOKEN_TYPE] == TEND) return compiler_throw(c, $@, $*, print("Unexpected EOF"));
    if (!tokenizer_token(&c{CTOK}, &c{CNEXT})) return compiler_throw(c, $@, $*);
    return c.[CCUR + TOKEN_TYPE];
}

function compiler_peek(c)
{
    return c.[CNEXT + TOKEN_TYPE];
}

function compiler_end(c)
{
    return compiler_peek(c) == TEND;
}

function compiler_match(c, t)
{
    return compiler_peek(c) == t ? compiler_advance(c) : FALSE;
}

function compiler_matches(c, t_start, t_end)
{
    return compiler_peek(c) >=! t_start and compiler_peek(c) <=! t_end ? compiler_advance(c) : FALSE;
}

function compiler_consume(c, t)
{
    return compiler_match(c, t) ? TRUE : compiler_throw_token(c, $@, $*, CNEXT, t);
}

function compiler_emit8(c, b)
{
    format(print, "%x\n", b);
    c.[CIP] += 1;
}

function compiler_emit16(c, w)
{
    compiler_emit8(c, w & 0xff);
    compiler_emit8(c, w >> 8);
}

function compiler_emit32(c, dw)
{
    compiler_emit16(c, dw & 0xffff);
    compiler_emit16(c, dw >> 16);
}

function compiler_getlater(c)
(r)
{
    if (c.[CIS_FIRST_PASS]) r = c.[CLATER_I];
    else r = c.[CLATER + VEC_PTR][c.[CLATER_I]];
    c.[CLATER_I] += 1;
    return r;
}

function compiler_setlater(c, index, value)
{
    if (!c.[CIS_FIRST_PASS]) return;
    if (!vec_set4(&c{CLATER}, index, value)) compiler_throw(c, $@, $*, format(print, "vec_set failed at index %u", index));
}

function compiler_relative(c, abs, opsize)
{
    return abs - c.[CIP] - opsize;
}

function compiler_pass(c, src, is_first_pass)
(state, s, i)
{
    c.[CIS_FIRST_PASS] = is_first_pass;
    c.[CLATER_I] = 0;
    c.[CIP] = c.[CORG] = 0;
    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);

    while (!compiler_end(c)) compiler_statement(c);

    state = 0;
    while (s = map_iter(&c{CSTRINGS}, &state))
    {
        compiler_emit32(c, s.[STRINGLEN]);
        compiler_emit32(c, s.[STRING + COMPILER_STRING_ADDR] + c.[CPROG_END] - c.{CSTRING_OFFSET} + 8);
        i = 0;
        while (i <! s.[STRINGLEN])
        {
            compiler_emit8(c, s.[STRINGPTR]{i});
            i += 1;
        }
    }

    c.[CPROG_END] = c.[CIP];
}

function compile(c, filename, src)
{
    compiler_try(c, .catch);
    c.[CCUR_FILE] = filename;
    c.[CSTRING_OFFSET] = 0;

    compiler_pass(c, src, TRUE);
    compiler_pass(c, src, FALSE);

    compiler_try_end(c);
.catch:
    if ((c.[CCUR + TOKEN_TYPE] == TSTRING or c.[CCUR + TOKEN_TYPE] == TCHARS) and c.[CCUR + TOKEN_VALUE + STRINGPTR]) free(c.[CCUR + TOKEN_VALUE + STRINGPTR]);
    if ((c.[CNEXT + TOKEN_TYPE] == TSTRING or c.[CNEXT + TOKEN_TYPE] == TCHARS) and c.[CNEXT + TOKEN_VALUE + STRINGPTR]) free(c.[CNEXT + TOKEN_VALUE + STRINGPTR]);
    return NULL;
}

function compiler_statement(c)
{
    switch (compiler_peek(c))
    {
        case TWHILE: return compiler_while(c);
        case TLEFTBRACE: return compiler_statements(c);
        case TINCLUDE: return compiler_include(c);
        case TCONST: return compiler_const(c);
        case TSTRUCT: return compiler_struct(c);
        default: compiler_expression(c); return compiler_consume(c, TSEMICOLON);
    }
}

function compiler_statements(c)
{
    compiler_consume(c, TLEFTBRACE);
    while (!compiler_match(c, TRIGHTBRACE)) compiler_statement(c);
}

function compiler_struct(c)
{
    compiler_consume(c, TSTRUCT);
    compiler_consume(c, TIDENT);
    compiler_consume(c, TEQUALS);
    do
    {
        compiler_consume(c, TLEFTBRACKET);
        compiler_consume(c, TIDENT);
        compiler_consume(c, TRIGHTBRACKET);
    } while (compiler_match(c, TCOMMA));
    compiler_consume(c, TSEMICOLON);
}

function compiler_const(c)
(s{STRING})
{
    compiler_consume(c, TCONST);
    do
    {
        compiler_consume(c, TIDENT);
        memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
        compiler_consume(c, TEQUALS);
        compiler_const_set(c, s, compiler_const_expression(c));
    } while (compiler_match(c, TCOMMA));
    compiler_consume(c, TSEMICOLON);
}

function compiler_include(c)
(f{FILE}, ocur_file, s{STRING}, src{STRING}, otok{TOKENIZER})
{
    compiler_consume(c, TINCLUDE);
    compiler_consume(c, TSTRING);

    ocur_file = c.[CCUR_FILE];
    memcpy(otok, &c{CTOK}, TOKENIZER);

    memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
    c.[CCUR_FILE] = s;

    src.[STRINGPTR] = NULL;
    compiler_try(c, .catch);
    if (!open(s, f, FALSE)) compiler_throw(c, $@, $*, format(print, "Could not open file \"%s\"", s));
    src.[STRINGLEN] = f.[FILE_SIZE];
    src.[STRINGPTR] = malloc(src.[STRINGLEN]);
    if (!src.[STRINGPTR]) compiler_throw(c, $@, $*, format(print, "Failed to allocate %uB of memory\n", src.[STRINGLEN]));

    if (!read(f, src.[STRINGLEN], src.[STRINGPTR])) compiler_throw(c, $@, $*, format(print, "Could not read file \"%s\"", s));

    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);

    while (!compiler_end(c)) compiler_statement(c);

    compiler_try_end(c);

    free(src.[STRINGPTR]);
    free(s.[STRINGPTR]);
    s.[STRINGPTR] = NULL;

    c.[CCUR_FILE] = ocur_file;
    memcpy(&c{CTOK}, otok, TOKENIZER);
    return;

.catch:
    free(src.[STRINGPTR]);
    free(s.[STRINGPTR]);
    s.[STRINGPTR] = NULL;
    compiler_throw(c, NULL, NULL);
}

function compiler_while(c)
(loop, loopend)
{
    loop = c.[CIP];

    compiler_consume(c, TWHILE);
    compiler_consume(c, TLEFTPAREN);
    compiler_expression(c);
    compiler_consume(c, TRIGHTPAREN);

    compiler_emit8(c, OTESTW);
    compiler_emit8(c, modrm(MODREG, REAX, REAX));

    loopend = compiler_getlater(c);
    compiler_emit16(c, OJZW);
    compiler_emit32(c, compiler_relative(c, loopend, 4));

    compiler_statement(c);

    compiler_emit8(c, OJMPW);
    compiler_emit32(c, compiler_relative(c, loop, 4));

    compiler_setlater(c, loopend, c.[CIP]);
}

function compiler_const_expression(c)
(r)
{
    c.[CIS_CONST_EXPR] = TRUE;
    r = compiler_expression(c);
    c.[CIS_CONST_EXPR] = FALSE;
    return r;
}

function compiler_expression(c)
{
    return compiler_primary(c);
}

function compiler_primary(c)
(ident{COMPILER_IDENT})
{
    if (c.[CIS_CONST_EXPR])
    {
        switch (compiler_advance(c))
        {
            case TNUM: return c.[CCUR + TOKEN_VALUE];
            default: return compiler_throw_token(c, $@, $*, CCUR, 0);
        }
    }

    switch (compiler_advance(c))
    {
        case TIDENT:
            if (compiler_global_get(c, &c{CCUR + TOKEN_VALUE}, ident))
            {
                compiler_emit8(c, OMOVIMMW);
                compiler_emit8(c, modrm(MODREG, 0, REAX));
                compiler_emit32(c, ident.[COMPILER_IDENT_ADDR]);
            }
            else if (c.[CIS_FIRST_PASS])
            {
                c.[CIP] += 6;
            }
            else
            {
                compiler_throw(c, $@, $*, format(print, "Undefined identifier %s", &c{CCUR + TOKEN_VALUE}));
            }
            break;
        case TSTRING:
            compiler_emit8(c, OMOVREGIMMW + REAX);
            compiler_emit32(c, compiler_string_get(c, &c{CCUR + TOKEN_VALUE}));
            break;
        case TNUM:
            compiler_emit8(c, OMOVIMMW);
            compiler_emit8(c, modrm(MODREG, 0, REAX));
            compiler_emit32(c, c.[CCUR + TOKEN_VALUE]);
            break;
        default:
            compiler_throw_token(c, $@, $*, CCUR, 0);
            break;
    }

    while (compiler_post(c));
}

function compiler_post(c)
{
    if (!compiler_match(c, TLEFTPAREN)) return FALSE;
    compiler_expression(c);
    compiler_consume(c, TRIGHTPAREN);
    print("CALL\n");
    return TRUE;
}

function compiler_const_set(c, name, address)
(s{STRING})
{
    if (map_get(&c{CIDENTS}, name, s)) return TRUE;
    if (!map_set(&c{CIDENTS}, strdup(name, s), &address)) return compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", name, address), free(s.[STRINGPTR]));
    return TRUE;
}

function compiler_global_get(c, name, out)
{
    return map_get(&c{CIDENTS}, name, out);
}

function compiler_string_get(c, s)
(x)
{
    if (map_get(&c{CSTRINGS}, s, &x))
    {
        free(s.[STRINGPTR]);
        s.[STRINGPTR] = NULL;
        return x + c.[CPROG_END] - c.[CSTRING_OFFSET];
    }

    x = c.[CSTRING_OFFSET];
    c.[CSTRING_OFFSET] += 8 + s.[STRINGLEN];
    if (!map_set(&c{CSTRINGS}, s, &x)) compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", s, x));

    return 0;
}