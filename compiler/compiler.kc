include "compiler/tokenizer.kc"

struct COMPILER = TOKENIZER{CTOK}, MAP{CIDENTS}, TOKEN{CCUR}, TOKEN{CNEXT}, [CBIN], [CEBP], [CCUR_FILE];
struct COMPILER_IDENT = [COMPILER_IDENT_ADDR];

function compiler_init(c)
{
    c.[CEBP] = 0;
    c.[CCUR_FILE] = "None";
    if (!map_init(&c{CIDENTS}, 1024, STRING, COMPILER_IDENT, strcmp, hash_string, NULL)) return FALSE;
    return TRUE;
}

function compiler_die(c, file, line)
{
    format(print, ", compiler died at %s(%x) in file \"%s\", line %x, column %x\n", file, line, c.[CCUR_FILE], c.[CTOK + TLINE], c.[CTOK + TCOL]);

    MOV EDI, [c]
    MOV EAX, [EDI + CEBP]
    TEST EAX, EAX
    JZ .ret
    MOV EBP, EAX
.ret:
    return 0;
}

function compiler_advance(c)
{
    memcpy(&c{CCUR}, &c{CNEXT}, TOKEN);
    if (c.[CCUR + TOKEN_TYPE] == TEND) return compiler_die(c, $@, $*, print("Unexpected EOF"));
    if (!tokenizer_token(&c{CTOK}, &c{CNEXT})) return compiler_die(c, $@, $*);
    return c.[CCUR + TOKEN_TYPE];
}

function compiler_peek(c)
{
    return c.[CNEXT + TOKEN_TYPE];
}

function compiler_end(c)
{
    return compiler_peek(c) == TEND;
}

function compiler_match(c, t)
{
    return compiler_peek(c) == t ? compiler_advance(c) : FALSE;
}

function compiler_matches(c, t_start, t_end)
{
    return compiler_peek(c) >=! t_start and compiler_peek(c) <=! t_end ? compiler_advance(c) : FALSE;
}

function compiler_consume(c, t)
{
    return compiler_match(c, t) ? TRUE : compiler_die(c, $@, $*, format(print, "Unexpected token %x(\"%s\")", c.[CNEXT + TOKEN_TYPE], &c{CNEXT + TOKEN_VALUE}));
}

function compiler_pass(c, src, is_first_pass)
{
    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);

    while (!compiler_end(c)) compiler_statement(c);
}

function compile(c, filename, src)
{
    MOV EAX, [c]
    MOV [EAX + CEBP], EBP
    c.[CCUR_FILE] = filename;

    compiler_pass(c, src, FALSE);
    compiler_pass(c, src, TRUE);

    c.[CEBP] = 0;
    return NULL;
}

function compiler_statement(c)
{
    switch (compiler_peek(c))
    {
        case TWHILE: return compiler_while(c);
        default: compiler_expression(c); return compiler_consume(c, TSEMICOLON);
    }
}

function compiler_while(c)
{
    compiler_consume(c, TWHILE);
    compiler_consume(c, TLEFTPAREN);
    compiler_expression(c);
    compiler_consume(c, TRIGHTPAREN);

    compiler_die(c, $@, $*, print("Unimplemented"));
}

function compiler_expression(c)
{
    compiler_die(c, $@, $*, print("Unimplemented"));
}

function compiler_const_set(c, name, address)
{
    if (!map_set(&c{CIDENTS}, name, &address)) return compiler_die(c, $@, $*, format(print, "map_set(\"%s\", %x) failed", name, address));
    return TRUE;
}