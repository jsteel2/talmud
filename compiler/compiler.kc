include "compiler/tokenizer.kc"

struct COMPILER = TOKENIZER{CTOK}, MAP{CIDENTS}, TOKEN{CCUR}, TOKEN{CNEXT}, [CBIN], [CEBP], [CCUR_FILE];
struct COMPILER_IDENT = [COMPILER_IDENT_ADDR];

function compiler_init(c)
{
    c.[CEBP] = 0;
    c.[CCUR_FILE] = "None";
    if (!map_init(&c{CIDENTS}, 1024, STRING, COMPILER_IDENT, strcmp, hash_string, NULL)) return FALSE;
    return TRUE;
}

function compiler_die(c, file, line)
{
    format(print, ", compiler died at %s(%x) in file %s\n", file, line, c.[CCUR_FILE]);

    MOV EDI, [c]
    MOV EAX, [EDI + CEBP]
    TEST EAX, EAX
    JZ .ret
    MOV EBP, EAX
.ret:
    return 0;
}

function compiler_advance(c)
{
    memcpy(&c{CCUR}, &c{CNEXT}, TOKEN);
    if (c.[CCUR + TOKEN_TYPE] == TEND) return compiler_die(c, $@, $*, print("Unexpected EOF"));
    if (!tokenizer_token(&c{CTOK}, &c{CNEXT})) return compiler_die(c, $@, $*);
    return c.[CCUR + TOKEN_TYPE];
}

function compiler_pass(c, src, is_first_pass)
{
    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);
    format(print, "got token type %x value %s\n", c.[CNEXT + TOKEN_TYPE], &c{CNEXT + TOKEN_VALUE});
}

function compile(c, filename, src)
{
    MOV EAX, [c]
    MOV [EAX + CEBP], EBP
    c.[CCUR_FILE] = filename;

    compiler_pass(c, src, FALSE);
    compiler_pass(c, src, TRUE);

    c.[CEBP] = 0;
    return NULL;
}

function compiler_const_set(c, name, address)
{
    if (!map_set(&c{CIDENTS}, name, &address)) return compiler_die(c, $@, $*, format(print, "map_set(\"%s\", %x) failed", name, address));
    return TRUE;
}