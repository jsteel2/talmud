include "compiler/tokenizer.kc"
include "compiler/asm.kc"

struct COMPILER = TOKENIZER{CTOK}, MAP{CIDENTS}, MAP{CLOCALS}, MAP{CSTRINGS}, TOKEN{CCUR}, TOKEN{CNEXT}, VEC{CLATER}, [CLATER_I], [CBIN], [CEXCEPT], [CCUR_FILE], [CIS_FIRST_PASS], [CIP], [CORG], [CSTRING_OFFSET], [CPROG_END], {CUSE32};
const IDENT_FLAG_VALID = 1;
const IDENT_FLAG_LOCAL = 1 << 1;
const IDENT_FLAG_ADDRESS = 1 << 2;
const IDENT_FLAG_RELOCATE = 1 << 3;
struct COMPILER_IDENT = [COMPILER_IDENT_ADDR], {COMPILER_IDENT_FLAGS};
struct COMPILER_STRING = [COMPILER_STRING_ADDR];

function compiler_init(c)
{
    c.[CEXCEPT] = 0;
    c.[CCUR_FILE] = "None";
    if (!map_init(&c{CIDENTS}, 1024, STRING, COMPILER_IDENT, strcmp, hash_string, free_string)) return FALSE;
    if (!map_init(&c{CSTRINGS}, 64, STRING, COMPILER_STRING, strcmp, hash_string, free_string)) return FALSE;
    if (!map_init(&c{CLOCALS}, 32, STRING, COMPILER_IDENT, strcmp, hash_string, NULL)) return FALSE;
    if (!vec_init(&c{CLATER}, 1024, 4)) return FALSE;
    return TRUE;
}

function compiler_free(c)
{
    map_free(&c{CIDENTS});
    map_free(&c{CSTRINGS});
    map_free(&c{CLOCALS});
    vec_free(&c{CLATER});
}

function compiler_throw(c, file, line)
{
    if (file) format(print, ", compiler died at %s(%u) in file \"%s\", line %u, column %u\n", file, line, c.[CCUR_FILE], c.[CTOK + TLINE], c.[CTOK + TCOL]);

    if (!c.[CEXCEPT]) return FALSE;

    MOV EDI, [c]
    MOV ESP, [EDI + CEXCEPT]
    POP EAX
    POP [EDI + CEXCEPT]
    POP EBP
    JMP EAX
}

compiler_try:
    POP EAX # return address
    POP EDI # compiler
    POP EBX # label
    PUSH EBP
    PUSH [EDI + CEXCEPT]
    PUSH EBX
    MOV [EDI + CEXCEPT], ESP
    SUB ESP, 8
    JMP EAX

compiler_try_end:
    POP EAX # return address
    POP EDI # compiler
    MOV ESP, [EDI + CEXCEPT]
    POP EBX
    POP [EDI + CEXCEPT]
    JMP EAX

function compiler_throw_token(c, file, line, token, expected)
(s{STRING}, buf{10}, sp)
{
    s.[STRINGPTR] = buf;
    if (c.[token + TOKEN_TYPE] == TNUM) sp = int2str(s, c.[token + TOKEN_VALUE], 10, FALSE);
    else sp = &c{token + TOKEN_VALUE};
    format(print, "Unexpected token %u(\"%s\")", c.[token + TOKEN_TYPE], sp);
    if (expected) sp = int2str(s, expected, 10, FALSE);
    else sp = "Unknown";
    return compiler_throw(c, file, line, format(print, " expected type %s", sp));
}

function compiler_advance(c)
{
    memcpy(&c{CCUR}, &c{CNEXT}, TOKEN);
    if (c.[CCUR + TOKEN_TYPE] == TEND) return compiler_throw(c, $@, $*, print("Unexpected EOF"));
    if (!tokenizer_token(&c{CTOK}, &c{CNEXT})) return compiler_throw(c, $@, $*);
    return c.[CCUR + TOKEN_TYPE];
}

function compiler_peek(c)
{
    return c.[CNEXT + TOKEN_TYPE];
}

function compiler_end(c)
{
    return compiler_peek(c) == TEND;
}

function compiler_match(c, t)
{
    return compiler_peek(c) == t ? compiler_advance(c) : FALSE;
}

function compiler_matches(c, t_start, t_end)
{
    return compiler_peek(c) >=! t_start and compiler_peek(c) <=! t_end ? compiler_advance(c) : FALSE;
}

function compiler_consume(c, t)
{
    return compiler_match(c, t) ? TRUE : compiler_throw_token(c, $@, $*, CNEXT, t);
}

function compiler_emit8(c, b)
{
    if (!c.[CIS_FIRST_PASS]) c.[CBIN]{c.[CIP] - c.[CORG]} = b;
    c.[CIP] += 1;
    return c.[CIP] - 1;
}

function compiler_emit16(c, w)
{
    compiler_emit8(c, w & 0xff);
    compiler_emit8(c, w >> 8);
    return c.[CIP] - 2;
}

function compiler_emit32(c, dw)
{
    compiler_emit16(c, dw & 0xffff);
    compiler_emit16(c, dw >> 16);
    return c.[CIP] - 4;
}

function compiler_emitvar(c, x)
{
    if (x >! 0xffff) compiler_emit32(c, x);
    else if (x >! 0xff) compiler_emit16(c, x);
    else compiler_emit8(c, x);
}

function compiler_getlater(c)
(r)
{
    if (c.[CIS_FIRST_PASS]) r = c.[CLATER_I];
    else r = c.[CLATER + VEC_PTR][c.[CLATER_I]];
    c.[CLATER_I] += 1;
    return r;
}

function compiler_setlater(c, index, value)
{
    if (!c.[CIS_FIRST_PASS]) return;
    if (!vec_set4(&c{CLATER}, index, value)) compiler_throw(c, $@, $*, format(print, "vec_set failed at index %u", index));
}

function compiler_relative(c, abs, opsize)
{
    return abs - c.[CIP] - opsize;
}

function compiler_shift(c, i)
(ip)
{
    ip = c.[CIP] - c.[CORG];
    i -= c.[CORG];
    if (!c.[CIS_FIRST_PASS]) memmove(c.[CBIN] + i, c.[CBIN] + ip, ip - i);
    c.[CIP] -= ip - i;
}

function compiler_pass(c, src, is_first_pass)
(state, s, i)
{
    c.[CIS_FIRST_PASS] = is_first_pass;
    c.[CLATER_I] = 0;
    c.[CIP] = c.[CORG];
    c{CUSE32} = TRUE;
    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);

    while (!compiler_end(c)) compiler_statement(c);
    
    compiler_emit8(c, ORET);

    state = 0;
    while (s = map_iter(&c{CSTRINGS}, &state))
    {
        compiler_emit32(c, s.[STRINGLEN]);
        compiler_emit32(c, c.[CIP] + 4);
        i = 0;
        while (i <! s.[STRINGLEN])
        {
            compiler_emit8(c, s.[STRINGPTR]{i});
            i += 1;
        }
    }
}

function compile(c, filename, src)
{
    compiler_try(c, .catch);
    c.[CCUR_FILE] = filename;
    c.[CSTRING_OFFSET] = 0;
    c.[CBIN] = NULL;

    c.[CORG] = 0;
    compiler_pass(c, src, TRUE);
    c.[CORG] = c.[CBIN] = malloc(c.[CIP]);
    if (!c.[CBIN]) compiler_throw(c, $@, $*, format(print, "Failed to allocate %uB of memory", c.[CIP]));
    c.[CPROG_END] = c.[CIP] + c.[CORG];
    compiler_pass(c, src, FALSE);

    compiler_try_end(c);
    map_free2(&c{CSTRINGS});
    return c.[CBIN];

.catch:
    if ((c.[CCUR + TOKEN_TYPE] == TSTRING or c.[CCUR + TOKEN_TYPE] == TCHARS) and c.[CCUR + TOKEN_VALUE + STRINGPTR]) free(c.[CCUR + TOKEN_VALUE + STRINGPTR]);
    if ((c.[CNEXT + TOKEN_TYPE] == TSTRING or c.[CNEXT + TOKEN_TYPE] == TCHARS) and c.[CNEXT + TOKEN_VALUE + STRINGPTR]) free(c.[CNEXT + TOKEN_VALUE + STRINGPTR]);
    free(c.[CBIN]);
    map_free2(&c{CSTRINGS});
    return NULL;
}

function compiler_statement(c)
(econst)
{
    switch (compiler_peek(c))
    {
        case TWHILE: return compiler_while(c);
        case TDO: return compiler_do(c);
        case TIF: return compiler_if(c);
        case TLEFTBRACE: return compiler_statements(c);
        case TINCLUDE: return compiler_include(c);
        case TCONST: return compiler_const(c);
        case TSTRUCT: return compiler_struct(c);
        case TFUNCTION: return compiler_function(c);
        case TRETURN: return compiler_return(c);
        case TSEMICOLON: return compiler_advance(c);
        case TCLD: return compiler_aemit8(c, OCLD);
        case TSTD: return compiler_aemit8(c, OSTD);
        case TREP: return compiler_aemit8(c, OREP);
        case TMOVSB: return compiler_aemit8(c, OMOVSB);
        case TCMPSB: return compiler_aemit8(c, OCMPSB);
        case TMOV: return compiler_asm_mov(c);
        case TADD: return compiler_asm_grp1(c, OADDMRB, OGRP1ADD);
        case TDEC: return compiler_asm_incdec(c, ODECR);
        case TJZ: return compiler_asm_jcc(c, OJZB, OJZW);
        default: compiler_expression(c, &econst); return compiler_consume(c, TSEMICOLON);
    }
}

function compiler_aemit8(c, o)
{
    compiler_advance(c);
    compiler_emit8(c, o);
}

function compiler_statements(c)
{
    compiler_consume(c, TLEFTBRACE);
    while (!compiler_match(c, TRIGHTBRACE)) compiler_statement(c);
}

function compiler_return(c)
(r, econst)
{
    compiler_consume(c, TRETURN);
    if (!compiler_match(c, TSEMICOLON))
    {
        r = compiler_expression(c, &econst);
        if (econst)
        {
            compiler_emit8(c, OMOVRIMMW + REAX);
            compiler_emit32(c, r);
        }
        compiler_consume(c, TSEMICOLON);
    }
    compiler_emit8(c, OLEAVE);
    compiler_emit8(c, ORET);
}

function compiler_function(c)
(i, x, t, s{STRING})
{
    compiler_consume(c, TFUNCTION);
    compiler_consume(c, TIDENT);
    compiler_label_set(c, &c{CCUR + TOKEN_VALUE});
    compiler_consume(c, TLEFTPAREN);

    i = 4;
    while (compiler_match(c, TIDENT))
    {
        compiler_local_set(c, &c{CCUR + TOKEN_VALUE}, i += 4, 0);
        if (compiler_peek(c) != TRIGHTPAREN) compiler_consume(c, TCOMMA);
    }
    compiler_consume(c, TRIGHTPAREN);

    i = 0;
    if (compiler_match(c, TLEFTPAREN))
    {
        do
        {
            compiler_consume(c, TIDENT);
            memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
            if (t = compiler_match(c, TLEFTBRACE)) x = 1 *! compiler_const_expression(c);
            else if (t = compiler_match(c, TLEFTCHEVRON)) x = 2 *! compiler_const_expression(c);
            else if (t = compiler_match(c, TLEFTBRACKET)) x = 4 *! compiler_const_expression(c);
            else x = 4;
            compiler_local_set(c, s, i -= x, t ? IDENT_FLAG_ADDRESS : 0);
            if (t) compiler_consume(c, t + 1);
        } while (compiler_match(c, TCOMMA));
        compiler_consume(c, TRIGHTPAREN);
        x = TRUE;
    }

    compiler_emit8(c, OPUSHR + REBP);
    compiler_emit8(c, OMOVRMW);
    compiler_emit8(c, modrm(MODREG, REBP, RESP));

    if (x)
    {
        compiler_emit8(c, OGRP1MIMMWW);
        compiler_emit8(c, modrm(MODREG, OGRP1SUB, RESP));
        compiler_emit32(c, -i);
    }

    compiler_statement(c);
    map_free2(&c{CLOCALS});

    compiler_emit8(c, OLEAVE);
    compiler_emit8(c, ORET);
}

function compiler_struct(c)
(s{STRING}, i, t, a)
{
    compiler_consume(c, TSTRUCT);
    compiler_consume(c, TIDENT);
    memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
    compiler_consume(c, TEQUALS);
    i = 0;
    do
    {
        if (t = compiler_match(c, TLEFTBRACKET)) a = 4;
        else if (t = compiler_match(c, TLEFTCHEVRON)) a = 2;
        else if (t = compiler_match(c, TLEFTBRACE)) a = 1;
        else compiler_throw_token(c, $@, $*, CNEXT, TLEFTBRACKET);
        compiler_consume(c, TIDENT);
        compiler_const_set(c, &c{CCUR + TOKEN_VALUE}, i);
        compiler_consume(c, t + 1);
        i += 4;
    } while (compiler_match(c, TCOMMA));
    compiler_const_set(c, s, i);
    compiler_consume(c, TSEMICOLON);
}

function compiler_const(c)
(s{STRING})
{
    compiler_consume(c, TCONST);
    do
    {
        compiler_consume(c, TIDENT);
        memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
        compiler_consume(c, TEQUALS);
        compiler_const_set(c, s, compiler_const_expression(c));
    } while (compiler_match(c, TCOMMA));
    compiler_consume(c, TSEMICOLON);
}

function compiler_include(c)
(f{FILE}, ocur_file, ocur{TOKEN}, onext{TOKEN}, s{STRING}, src{STRING}, otok{TOKENIZER})
{
    compiler_consume(c, TINCLUDE);
    compiler_consume(c, TSTRING);

    ocur_file = c.[CCUR_FILE];
    memcpy(otok, &c{CTOK}, TOKENIZER);
    memcpy(ocur, &c{CCUR}, TOKEN);
    memcpy(onext, &c{CNEXT}, TOKEN);

    memcpy(s, &c{CCUR + TOKEN_VALUE}, STRING);
    c.[CCUR_FILE] = s;

    src.[STRINGPTR] = NULL;
    compiler_try(c, .catch);
    if (!open(s, f, FALSE)) compiler_throw(c, $@, $*, format(print, "Could not open file \"%s\"", s));
    src.[STRINGLEN] = f.[FILE_SIZE];
    src.[STRINGPTR] = malloc(src.[STRINGLEN]);
    if (!src.[STRINGPTR]) compiler_throw(c, $@, $*, format(print, "Failed to allocate %uB of memory\n", src.[STRINGLEN]));

    if (!read(f, src.[STRINGLEN], src.[STRINGPTR])) compiler_throw(c, $@, $*, format(print, "Could not read file \"%s\"", s));

    tokenizer_init(&c{CTOK}, src);

    c.[CNEXT + TOKEN_TYPE] = TINVALID;
    compiler_advance(c);

    while (!compiler_end(c)) compiler_statement(c);

    compiler_try_end(c);

    free(src.[STRINGPTR]);
    free(s.[STRINGPTR]);
    s.[STRINGPTR] = NULL;

    c.[CCUR_FILE] = ocur_file;
    memcpy(&c{CTOK}, otok, TOKENIZER);
    memcpy(&c{CCUR}, ocur, TOKEN);
    memcpy(&c{CNEXT}, onext, TOKEN);
    return;

.catch:
    free(src.[STRINGPTR]);
    free(s.[STRINGPTR]);
    s.[STRINGPTR] = NULL;
    compiler_throw(c, NULL, NULL);
}

function compiler_while(c)
(loop, loopend, r, econst)
{
    loop = c.[CIP];

    compiler_consume(c, TWHILE);
    compiler_consume(c, TLEFTPAREN);
    r = compiler_expression(c, &econst);
    compiler_consume(c, TRIGHTPAREN);

    loopend = compiler_getlater(c);
    if (econst)
    {
        if (!r)
        {
            compiler_emit8(c, OJMPW);
            compiler_emit32(c, compiler_relative(c, loopend + c.[CORG], 4));
        }
        else
        {
            compiler_emit8(c, ONOP);
            compiler_emit32(c, 0x90909090);
        }
    }
    else
    {
        compiler_emit8(c, OTESTW);
        compiler_emit8(c, modrm(MODREG, REAX, REAX));

        compiler_emit16(c, OJZW);
        compiler_emit32(c, compiler_relative(c, loopend + c.[CORG], 4));
    }

    compiler_statement(c);

    compiler_emit8(c, OJMPW);
    compiler_emit32(c, compiler_relative(c, loop, 4));

    compiler_setlater(c, loopend, c.[CIP]);
}

function compiler_do(c)
(loop, r, econst)
{
    loop = c.[CIP];
    compiler_consume(c, TDO);
    compiler_statement(c);

    compiler_consume(c, TWHILE);
    compiler_consume(c, TLEFTPAREN);
    r = compiler_expression(c, &econst);
    compiler_consume(c, TRIGHTPAREN);

    if (econst)
    {
        if (r)
        {
            compiler_emit8(c, OJMPW);
            compiler_emit32(c, compiler_relative(c, loop, 4));
        }
        else
        {
            compiler_emit8(c, ONOP);
            compiler_emit32(c, 0x90909090);
        }
    }
    else
    {
        compiler_emit8(c, OTESTW);
        compiler_emit8(c, modrm(MODREG, REAX, REAX));

        compiler_emit16(c, OJNZW);
        compiler_emit32(c, compiler_relative(c, loop, 4));
    }
}

function compiler_if(c)
(econst, ifend, r)
{
    compiler_consume(c, TIF);
    compiler_consume(c, TLEFTPAREN);
    r = compiler_expression(c, &econst);
    compiler_consume(c, TRIGHTPAREN);
    
    ifend = compiler_getlater(c);
    if (econst)
    {
        if (!r)
        {
            compiler_emit8(c, OJMPW);
            compiler_emit32(c, compiler_relative(c, ifend + c.[CORG], 4));
        }
        else
        {
            compiler_emit8(c, ONOP);
            compiler_emit32(c, 0x90909090);
        }
    }
    else
    {
        compiler_emit8(c, OTESTW);
        compiler_emit8(c, modrm(MODREG, REAX, REAX));

        compiler_emit16(c, OJZW);
        compiler_emit32(c, compiler_relative(c, ifend + c.[CORG], 4));
    }

    compiler_statement(c);
    
    compiler_setlater(c, ifend, c.[CIP]);
}

function compiler_const_expression(c)
(r, econst)
{
    r = compiler_expression(c, &econst);
    if (!econst) compiler_throw(c, $@, $*, print("Expression not constant"));
    return r;
}

function compiler_expression(c, econst)
{
    *econst = TRUE;
    return compiler_binary(c, precs, econst);
}

function compiler_binary(c, prec, econst)
(t, last, l, r, lconst, rconst, i)
{
    if (!prec{PREC_START}) return compiler_unary(c, econst);

    lconst = TRUE;
    l = compiler_binary(c, prec + PREC, &lconst);
    if (!lconst) *econst = FALSE;

    last = c{CCUR + TOKEN_TYPE};
    while (t = compiler_matches(c, prec{PREC_START}, prec{PREC_END}))
    {
        rconst = TRUE;
        i = compiler_emit8(c, OPUSHR + REAX);
        if (prec{PREC_ASSOC} == ASSOC_LEFT) r = compiler_binary(c, prec + PREC, &rconst);
        else if (prec{PREC_ASSOC} == ASSOC_MIDDLE) r = compiler_binary(c, precs, &rconst);
        else r = compiler_binary(c, prec, &rconst);
        if (!rconst) *econst = FALSE;
        if (lconst or rconst) compiler_shift(c, i);

        switch (t)
        {
            case TPLUS:
                if (*econst)
                {
                    l = l + r;
                }
                else if (rconst)
                {
                    compiler_emit8(c, OADDEAXIMMW);
                    compiler_emit32(c, r);
                }
                break;
            case TMINUS:
                if (*econst)
                {
                    l = l - r;
                }
                else if (rconst)
                {
                    compiler_emit8(c, OSUBEAXIMMW);
                    compiler_emit32(c, r);
                }
                break;
            case TSTARU:
            case TSTARS:
                if (*econst)
                {
                    l = t == TSTARS ? l *$ r : l *! r;
                }
                else if (lconst)
                {
                    print("todo\n");
                }
                else if (rconst)
                {
                    print("todo\n");
                }
                else
                {
                    compiler_emit8(c, OPOPR + REDX);
                    compiler_emit8(c, OGRP3W);
                    compiler_emit8(c, modrm(MODREG, t == TSTARS ? OGRP3IMUL : OGRP3MUL, REDX));
                }
                break;
            case TEQUALS:
            case TPLUSEQUALS:
                if (*econst)
                {
                    print("todo\n");
                }
                else if (rconst)
                {
                    if (last == TRIGHTCHEVRON) compiler_emit8(c, OSIZEOVERRIDE);
                    if (last == TRIGHTBRACE) compiler_emit8(c, t != TEQUALS ? OGRP1MIMMBB : OMOVMIMMB);
                    else compiler_emit8(c, t != TEQUALS ? OGRP1MIMMWW : OMOVMIMMW);
                    compiler_emit8(c, modrm(MODMEM, 0, REAX));
                    if (last == TRIGHTBRACE) compiler_emit8(c, r);
                    else if (last == TRIGHTCHEVRON) compiler_emit16(c, r);
                    else compiler_emit32(c, r);
                }
                else if (lconst)
                {
                    print("todo\n");
                }
                else
                {
                    compiler_emit8(c, OPOPR + RECX);
                    if (last == TRIGHTCHEVRON) compiler_emit8(c, OSIZEOVERRIDE);
                    if (last == TRIGHTBRACE) compiler_emit8(c, t == TPLUSEQUALS ? OADDMRB : OMOVMRB);
                    else compiler_emit8(c, t == TPLUSEQUALS ? OADDMRW : OMOVMRW);
                    compiler_emit8(c, modrm(MODMEM, REAX, RECX));
                }
                break;
            case TSTARUEQUALS:
            case TSTARSEQUALS:
                print("todo se\n");
                break;
            case TGREATERTHANU:
            case TGREATERTHANS:
            case TGREATEREQUALSU:
            case TGREATEREQUALSS:
            case TLESSTHANU:
            case TLESSTHANS:
            case TLESSEQUALSU:
            case TLESSEQUALSS:
                if (*econst)
                {
                    print("todo cmp");
                }
                else if (rconst)
                {
                    print("todo cmp");
                }
                else if (lconst)
                {
                    print("todo cmp");
                }
                else
                {
                    compiler_emit8(c, OPOPR + REDX);

                    compiler_emit8(c, OCMPMRW);
                    compiler_emit8(c, modrm(MODREG, REAX, REDX));

                    compiler_emit8(c, OMOVRIMMW + REAX);
                    compiler_emit32(c, 0);
                    
                    switch (t)
                    {
                        case TGREATERTHANU: compiler_emit16(c, OSETA); break;
                        case TGREATERTHANS: compiler_emit16(c, OSETG); break;
                        case TGREATEREQUALSU: compiler_emit16(c, OSETAE); break;
                        case TGREATEREQUALSS: compiler_emit16(c, OSETGE); break;
                        case TLESSTHANU: compiler_emit16(c, OSETB); break;
                        case TLESSTHANS: compiler_emit16(c, OSETL); break;
                        case TLESSEQUALSU: compiler_emit16(c, OSETBE); break;
                        case TLESSEQUALSS: compiler_emit16(c, OSETLE); break;
                    }
                    compiler_emit8(c, modrm(MODREG, REAX, REAX));
                }
                break;
            case TEQUALSEQUALS:
            case TNOTEQUALS:
                if (*econst)
                {
                    print("todo\n");
                }
                else if (rconst)
                {
                    compiler_emit8(c, OCMPEAXIMMW);
                    compiler_emit32(c, r);

                    compiler_emit8(c, OMOVRIMMW + REAX);
                    compiler_emit32(c, 0);

                    compiler_emit16(c, t == TEQUALSEQUALS ? OSETZ : OSETNZ);
                    compiler_emit8(c, modrm(MODREG, REAX, REAX));
                }
                else
                {
                    print("todo\n");
                }
                break;
            case TBITWISEAND:
            case TBITWISEOR:
            case TBITWISEXOR:
                if (*econst)
                {
                    print("todo\n");
                }
                else if (rconst)
                {
                    compiler_emit8(c, t == TBITWISEAND ? OANDEAXIMMW : t == TBITWISEOR ? OOREAXIMMW : OXOREAXIMMW);
                    compiler_emit32(c, r);
                }
                else
                {
                    print("todo\n");
                }
                break;
            case TQMARK:
                print("todo tern\n");
                compiler_consume(c, TCOLON);
                compiler_expression(c, &rconst);
                if (!rconst) *econst = FALSE;
                break;
            case TLOGICALAND:
                print("todo and\n");
                break;
            case TLOGICALOR:
                print("todo or\n");
                break;
            default: compiler_throw(c, $@, $*, format(print, "Unimplemented operand %u", t));
        }
        if (lconst) lconst = rconst;
        last = c{CCUR + TOKEN_TYPE};
    }

    return l;
}

function compiler_unary(c, econst)
(t, ident)
{
    switch (compiler_peek(c))
    {
        case TSTAR:
            print("todo\n");
            compiler_advance(c);
            *econst = FALSE;
            compiler_unary(c, econst);
            return;
        case TBANG:
            compiler_advance(c);
            t = compiler_unary(c, econst);
            if (*econst) return !t;

            compiler_emit8(c, OTESTW);
            compiler_emit8(c, modrm(MODREG, REAX, REAX));

            compiler_emit8(c, OMOVRIMMW + REAX);
            compiler_emit32(c, 0);

            compiler_emitvar(c, OSETZ);
            compiler_emit8(c, modrm(MODREG, REAX, REAX));
            return;
        case TBITWISEAND:
            compiler_advance(c);
            return compiler_primary(c, econst, TRUE);
        default:
            return compiler_primary(c, econst, FALSE);
    }
}

function compiler_primary(c, econst, ref)
(ident, f, r)
{
    switch (compiler_advance(c))
    {
        case TIDENT:
            if (f = compiler_ident_get(c, &c{CCUR + TOKEN_VALUE}, &ident))
            {
                if (ref or f & IDENT_FLAG_ADDRESS or (compiler_peek(c) >=! TEQUALS and compiler_peek(c) <=! TPLUSEQUALS))
                {
                    r = ident;
                    if (f & IDENT_FLAG_LOCAL)
                    {
                        *econst = FALSE;
                        compiler_emit8(c, OLEA);
                        compiler_emit8(c, modrm(MODDISPW, REAX, REBP));
                        compiler_emit32(c, ident);
                    }
                }
                else
                {
                    *econst = FALSE;
                    compiler_emit8(c, OMOVRMW);
                    if (f & IDENT_FLAG_LOCAL) compiler_emit8(c, modrm(MODDISPW, REAX, REBP));
                    else compiler_emit8(c, modrm(MODMEM, REAX, RDISP));
                    compiler_emit32(c, ident);
                }
            }
            else if (!c.[CIS_FIRST_PASS])
            {
                compiler_throw(c, $@, $*, format(print, "Undefined identifier %s", &c{CCUR + TOKEN_VALUE}));
            }
            break;
        case TSTRING:
            r = compiler_string_get(c, &c{CCUR + TOKEN_VALUE});
            break;
        case TNUM:
            r = c.[CCUR + TOKEN_VALUE];
            break;
        case TCHARS:
            r = 0;
            f = 0;
            while (f <! c.[CCUR + TOKEN_VALUE + STRINGLEN])
            {
                r <<= 8;
                r |= c.[CCUR + TOKEN_VALUE + STRINGPTR]{f};
                f += 1;
            }
            free(c.[CCUR + TOKEN_VALUE + STRINGPTR]);
            c.[CCUR + TOKEN_VALUE + STRINGPTR] = NULL;
            break;
        case TLEFTPAREN:
            r = compiler_expression(c, econst);
            compiler_consume(c, TRIGHTPAREN);
            break;
        default:
            compiler_throw_token(c, $@, $*, CCUR, 0);
            break;
    }

    while (compiler_post(c, econst, &r));
    return r;
}

function compiler_post(c, econst, r)
(align)
{
    align = TRUE;
.l:
    switch (compiler_peek(c))
    {
        case TLEFTPAREN: compiler_call(c, econst, *r); break;
        case TDOT: compiler_advance(c); align = FALSE; JMP .l
        case TLEFTBRACKET:
        case TLEFTCHEVRON:
        case TLEFTBRACE: *r = compiler_index(c, align, econst, *r); break;
        default: return FALSE;
    }

    return TRUE;
}

function compiler_call(c, lconst, r)
(s, i, e, econst)
{
    i = 0;
    s = compiler_getlater(c);
    compiler_consume(c, TLEFTPAREN);

    if (compiler_match(c, TRIGHTPAREN)) JMP .noargs
    compiler_emit8(c, OGRP1MIMMWB);
    compiler_emit8(c, modrm(MODREG, OGRP1SUB, RESP));
    compiler_emit8(c, s *! 4);

    if (!*lconst) 
    {
        compiler_emit8(c, OPUSHR + REAX);
        i = 1;
    }

    do
    {
        e = compiler_expression(c, &econst);

        if (econst)
        {
            compiler_emit8(c, OMOVMIMMW);
            compiler_emit8(c, modrm(MODDISPB, REAX, RSIB));
            compiler_emit8(c, sib(SIBSCALE1, SIBNOINDEX, RESP));
            compiler_emit8(c, i *! 4);
            compiler_emit32(c, e);
        }
        else
        {
            compiler_emit8(c, OMOVMRW);
            compiler_emit8(c, modrm(MODDISPB, REAX, RSIB));
            compiler_emit8(c, sib(SIBSCALE1, SIBNOINDEX, RESP));
            compiler_emit8(c, i *! 4);
        }

        i += 1;
    } while (compiler_match(c, TCOMMA));
    compiler_consume(c, TRIGHTPAREN);

    compiler_setlater(c, s, *lconst ? i : i - 1);

    if (!*lconst) compiler_emit8(c, OPOPR + REAX);

.noargs:
    if (*lconst)
    {
        compiler_emit8(c, OCALL);
        compiler_emit32(c, compiler_relative(c, r, 4));
    }
    else
    {
        compiler_emit8(c, OGRP5);
        compiler_emit8(c, modrm(MODREG, OGRP5CALL, REAX));
    }

    if (i >! 1 or (*lconst and i >! 0))
    {
        compiler_emit8(c, OGRP1MIMMWB);
        compiler_emit8(c, modrm(MODREG, OGRP1ADD, RESP));
        compiler_emit8(c, s *! 4);
    }
    *lconst = FALSE;
}

function compiler_index(c, align, lconst, r)
(scale, t, e, econst, op, i)
{
    if (t = compiler_match(c, TLEFTBRACKET)) { scale = SIBSCALE4; op = OMOVRMW; }
    else if (t = compiler_match(c, TLEFTCHEVRON)) { scale = SIBSCALE2; op = OMOVZXW; }
    else if (t = compiler_match(c, TLEFTBRACE)) { scale = SIBSCALE1; op = OMOVZXB; }
    if (!align) scale = SIBSCALE1;

    i = compiler_emit8(c, OPUSHR + REAX);
    e = compiler_expression(c, &econst);
    compiler_consume(c, t + 1);
    if (compiler_peek(c) >=! TEQUALS and compiler_peek(c) <=! TPLUSEQUALS) op = OLEA;

    if (*lconst or econst) compiler_shift(c, i);

    if (*lconst and econst)
    {
        if (op == OLEA) return r + e *! (1 << scale);
        *lconst = FALSE;
        compiler_emitvar(c, op);
        compiler_emit8(c, modrm(MODMEM, REAX, RDISP));
        compiler_emit32(c, r + e *! (1 << scale));
    }
    else if (*lconst)
    {
        *lconst = FALSE;
        compiler_emitvar(c, op);
        if (sib == SIBSCALE1)
        {
            compiler_emit8(c, modrm(MODDISPW, REAX, REAX));
        }
        else
        {
            compiler_emit8(c, modrm(MODMEM, REAX, RSIB));
            compiler_emit8(c, sib(scale, REAX, RDISP));
        }
        compiler_emit32(c, r);
    }
    else if (econst)
    {
        compiler_emitvar(c, op);
        compiler_emit8(c, modrm(MODDISPW, REAX, REAX));
        compiler_emit32(c, e *! (1 << scale));
    }
    else
    {
        compiler_emit8(c, OPOPR + RECX);
        compiler_emitvar(c, op);
        compiler_emit8(c, modrm(MODMEM, REAX, RSIB));
        compiler_emit8(c, sib(scale, REAX, RECX));
    }
}

function compiler_const_set(c, name, address)
(s{STRING}, x, ident{COMPILER_IDENT})
{
    if (map_get(&c{CIDENTS}, name, s)) x = name;
    else x = strdup(name, s);
    ident.[COMPILER_IDENT_ADDR] = address;
    ident{COMPILER_IDENT_FLAGS} = IDENT_FLAG_VALID | IDENT_FLAG_ADDRESS;
    if (!map_set(&c{CIDENTS}, x, ident)) return compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", name, address), x == name ? 0 : free(s.[STRINGPTR]));
    return TRUE;
}

function compiler_label_set(c, name)
(s{STRING}, ident{COMPILER_IDENT})
{
    if (c.[CIS_FIRST_PASS]) 
    {
        ident.[COMPILER_IDENT_ADDR] = c.[CIP];
        ident{COMPILER_IDENT_FLAGS} = IDENT_FLAG_VALID | IDENT_FLAG_RELOCATE | IDENT_FLAG_ADDRESS;
        if (!map_set(&c{CIDENTS}, strdup(name, s), ident)) compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", name, c.[CIP]), free(s.[STRINGPTR])); # FIX leak later (i dont remember what the leak is or if this still applies, curse you)
    }
    else
    {
        ident.[COMPILER_IDENT_ADDR] = c.[CIP];
        ident{COMPILER_IDENT_FLAGS} = IDENT_FLAG_VALID | IDENT_FLAG_ADDRESS;
        if (!map_set(&c{CIDENTS}, name, ident)) compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", name, c.[CIP]), free(s.[STRINGPTR]));
    }
}

function compiler_local_set(c, name, offset, flags)
(ident{COMPILER_IDENT})
{
    ident.[COMPILER_IDENT_ADDR] = offset;
    ident{COMPILER_IDENT_FLAGS} = IDENT_FLAG_VALID | IDENT_FLAG_LOCAL | flags;
    if (!map_set(&c{CLOCALS}, name, ident)) compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", name, offset));
}

function compiler_ident_get(c, name, out)
(ident{COMPILER_IDENT})
{
    if (map_get(&c{CLOCALS}, name, ident))
    {
        *out = ident.[COMPILER_IDENT_ADDR];
        return ident{COMPILER_IDENT_FLAGS};
    }

    if (map_get(&c{CIDENTS}, name, ident))
    {
        *out = ident.[COMPILER_IDENT_ADDR] + (ident{COMPILER_IDENT_FLAGS} & IDENT_FLAG_RELOCATE ? c.[CORG] : 0);
        return ident{COMPILER_IDENT_FLAGS};
    }
    return FALSE;
}

function compiler_string_get(c, s)
(x)
{
    if (map_get(&c{CSTRINGS}, s, &x))
    {
        free(s.[STRINGPTR]);
        s.[STRINGPTR] = NULL;
        return x + c.[CPROG_END] - c.[CSTRING_OFFSET];
    }

    x = c.[CSTRING_OFFSET];
    c.[CSTRING_OFFSET] += 8 + s.[STRINGLEN];
    if (!map_set(&c{CSTRINGS}, s, &x)) compiler_throw(c, $@, $*, format(print, "map_set(\"%s\", 0x%x) failed", s, x));

    return 0;
}

enum ASSOC_LEFT, ASSOC_RIGHT, ASSOC_MIDDLE;
struct PREC = {PREC_ASSOC}, {PREC_START}, {PREC_END};
precs:
    DB ASSOC_RIGHT, TEQUALS, TPLUSEQUALS # assign
    DB ASSOC_MIDDLE, TQMARK, TQMARK # ternary
    DB ASSOC_LEFT, TLOGICALOR, TLOGICALOR # logical or
    DB ASSOC_LEFT, TLOGICALAND, TLOGICALAND # logical and
    DB ASSOC_LEFT, TEQUALSEQUALS, TNOTEQUALS # equality
    DB ASSOC_LEFT, TGREATERTHANU, TLESSEQUALSS # comparison
    DB ASSOC_LEFT, TSHIFTRIGHT, TBITWISEAND # bitwise
    DB ASSOC_LEFT, TPLUS, TMINUS # term
    DB ASSOC_LEFT, TMODULOU, TSTARS # factor
    DB 0, 0, 0 # unary