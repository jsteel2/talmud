struct TOKENIZER = [TSRC], [TPOS], [TCOL], [TLINE];

struct TEND = {TINVALID}, {TNUM}, {TIDENT}, {TCHARS}, {TSTRING},

              {TWHILE},
              
              {TSEMICOLON}, {TLEFTPAREN}, {TRIGHTPAREN};

struct TOKEN = [TOKEN_TYPE], STRING{TOKEN_VALUE};

function tokenizer_init(t, src)
{
    t.[TSRC] = src;
    t.[TPOS] = 0;
    t.[TCOL] = 1;
    t.[TLINE] = 1;
}

function tokenizer_number_token(t, out)
{
    print("number Unimplemented");
    return FALSE;
}

function tokenizer_ident_token(t, out)
(s, p)
{
    p = t.[TSRC].[STRINGPTR];
    s = &out{TOKEN_VALUE};
    s.[STRINGPTR] = &p{t.[TPOS]};
    s.[STRINGLEN] = 0;
    do
    {
        s.[STRINGLEN] += 1;
        t.[TPOS] += 1;
    } while (t.[TPOS] <! t.[TSRC].[STRINGLEN] and (isalnum(p{t.[TPOS]}) or p{t.[TPOS]} == '_'));

    t.[TCOL] += s.[STRINGLEN];
    
    p = s.[STRINGLEN];
    switch (s.[STRINGPTR]{0})
    {
        case 'w':
            if (p == 5)
            {
                if (strcmp(s, "while")) out.[TOKEN_TYPE] = TWHILE;
                else break;
            }
            return TRUE;
    }

    out.[TOKEN_TYPE] = TIDENT;
    return TRUE;
}

function tokenizer_symbol_token(t, out)
(s, p, len)
{
    s = &out{TOKEN_VALUE};
    p = &t.[TSRC].[STRINGPTR]{t.[TPOS]};
    s.[STRINGPTR] = p;

    len = 1;
    switch (p{0})
    {
        case '(': out.[TOKEN_TYPE] = TLEFTPAREN; break;
        case ')': out.[TOKEN_TYPE] = TRIGHTPAREN; break;
        default: format(print, "Unknown symbol '%c'", p{0}); return FALSE;
    }

    t.[TCOL] += len;
    t.[TPOS] += len;
    s.[STRINGLEN] = len;
    return TRUE;
}

function tokenizer_string_token(t, out, type)
{
    print("string Unimplemented");
    return FALSE;
}

function tokenizer_token(t, out)
(c, p)
{
    if (t.[TPOS] >=! t.[TSRC].[STRINGLEN])
    {
        out.[TOKEN_TYPE] = TEND;
        return TRUE;
    }

    p = t.[TSRC].[STRINGPTR];

.skip:
    while (isspace(p{t.[TPOS]}))
    {
        if (p{t.[TPOS]} == '\n')
        {
            t.[TCOL] = 0;
            t.[TLINE] += 1;
        }
        t.[TCOL] += 1;
        if ((t.[TPOS] += 1) >=! t.[TSRC].[STRINGLEN])
        {
            out.[TOKEN_TYPE] = TEND;
            return TRUE;
        }
    }

    if (p{t.[TPOS]} == '#')
    {
        while (p{t.[TPOS] += 1} != '\n')
        {
            if (t.[TPOS] >=! t.[TSRC].[STRINGLEN])
            {
                out.[TOKEN_TYPE] = TEND;
                return TRUE;
            }
        }
        t.[TLINE] += 1;
        t.[TCOL] = 1;
        JMP .skip
    }

    c = p{t.[TPOS]};
    if (isnum(c)) return tokenizer_number_token(t, out);
    if (isalpha(c)) return tokenizer_ident_token(t, out);
    if (c == '\'') return tokenizer_string_token(t, out, TCHARS);
    if (c == '"') return tokenizer_string_token(t, out, TSTRING);

    return tokenizer_symbol_token(t, out);
}