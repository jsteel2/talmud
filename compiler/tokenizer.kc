struct TOKENIZER = [TSRC], [TPOS], [TCOL], [TLINE];

struct TEND = {TINVALID}, {TLEFTPAREN}, {TRIGHTPAREN}, {TNUM}, {TIDENT}, {TCHARS}, {TSTRING},

              {TWHILE}, {TINCLUDE}, {TCONST}, {TSTRUCT},
              
              {TLEFTBRACE}, {TRIGHTBRACE}, {TLEFTBRACKET}, {TRIGHTBRACKET}, {TSEMICOLON}, {TCOMMA},
              
              {TEQUALS};

struct TOKEN = [TOKEN_TYPE], STRING{TOKEN_VALUE};

function tokenizer_init(t, src)
{
    t.[TSRC] = src;
    t.[TPOS] = 0;
    t.[TCOL] = 1;
    t.[TLINE] = 1;
}

function tokenizer_number_token(t, out)
(s{STRING}, len)
{
    s.[STRINGLEN] = t.[TSRC].[STRINGLEN] - t.[TPOS];
    s.[STRINGPTR] = &t.[TSRC].[STRINGPTR]{t.[TPOS]};
    out.[TOKEN_TYPE] = TNUM;
    out.[TOKEN_VALUE] = str2int(s, 10, &len);
    t.[TPOS] += len;
    t.[TCOL] += len;
    return TRUE;
}

function tokenizer_ident_token(t, out)
(s, p)
{
    p = t.[TSRC].[STRINGPTR];
    s = &out{TOKEN_VALUE};
    s.[STRINGPTR] = &p{t.[TPOS]};
    s.[STRINGLEN] = 0;
    do
    {
        s.[STRINGLEN] += 1;
        t.[TPOS] += 1;
    } while (t.[TPOS] <! t.[TSRC].[STRINGLEN] and (isalnum(p{t.[TPOS]}) or p{t.[TPOS]} == '_'));

    t.[TCOL] += s.[STRINGLEN];
    
    p = s.[STRINGLEN];
    switch (s.[STRINGPTR]{0})
    {
        case 'c':
            if (strcmp(s, "const")) out.[TOKEN_TYPE] = TCONST;
            else break;
            return TRUE;
        case 'i':
            if (strcmp(s, "include")) out.[TOKEN_TYPE] = TINCLUDE;
            else break;
            return TRUE;
        case 's':
            if (strcmp(s, "struct")) out.[TOKEN_TYPE] = TSTRUCT;
            else break;
            return TRUE;
        case 'w':
            if (strcmp(s, "while")) out.[TOKEN_TYPE] = TWHILE;
            else break;
            return TRUE;
    }

    out.[TOKEN_TYPE] = TIDENT;
    return TRUE;
}

function tokenizer_symbol_token(t, out)
(s, p, len)
{
    s = &out{TOKEN_VALUE};
    p = &t.[TSRC].[STRINGPTR]{t.[TPOS]};
    s.[STRINGPTR] = p;

    len = 1;
    switch (p{0})
    {
        case '=': out.[TOKEN_TYPE] = TEQUALS; break;
        case '(': out.[TOKEN_TYPE] = TLEFTPAREN; break;
        case ')': out.[TOKEN_TYPE] = TRIGHTPAREN; break;
        case '{': out.[TOKEN_TYPE] = TLEFTBRACE; break;
        case '}': out.[TOKEN_TYPE] = TRIGHTBRACE; break;
        case '[': out.[TOKEN_TYPE] = TLEFTBRACKET; break;
        case ']': out.[TOKEN_TYPE] = TRIGHTBRACKET; break;
        case ';': out.[TOKEN_TYPE] = TSEMICOLON; break;
        case ',': out.[TOKEN_TYPE] = TCOMMA; break;
        default: format(print, "Unknown symbol '%c'", p{0}); return FALSE;
    }

    t.[TCOL] += len;
    t.[TPOS] += len;
    s.[STRINGLEN] = len;
    return TRUE;
}

function tokenizer_string_token(t, out, type)
(v{VEC}, p, c)
{
    c = type == TCHARS ? '\'' : '"';
    vec_init(v, 32, 1);

    p = t.[TSRC].[STRINGPTR];
    t.[TPOS] += 1;
    t.[TCOL] += 1;
    while (t.[TPOS] <! t.[TSRC].[STRINGLEN] and p{t.[TPOS]} != c)
    {
        if (p{t.[TPOS]} == '\\')
        {
            t.[TPOS] += 1;
            t.[TCOL] += 1;
            switch (p{t.[TPOS]})
            {
                case 'n': vec_push1(v, '\n'); break;
                default: format(print, "Unknown escape %c", p{t.[TPOS]}); return FALSE;
            }
        }
        else
        {
            vec_push1(v, p{t.[TPOS]});
        }
        t.[TPOS] += 1;
        t.[TCOL] += 1;
    }

    t.[TPOS] += 1;
    t.[TCOL] += 1;
    out.[TOKEN_TYPE] = type;
    out.[TOKEN_VALUE + STRINGLEN] = v.[VEC_LEN];
    out.[TOKEN_VALUE + STRINGPTR] = v.[VEC_PTR];
    return TRUE;
}

function tokenizer_token(t, out)
(c, p)
{
    if (t.[TPOS] >=! t.[TSRC].[STRINGLEN])
    {
        out.[TOKEN_TYPE] = TEND;
        return TRUE;
    }

    p = t.[TSRC].[STRINGPTR];

.skip:
    while (isspace(p{t.[TPOS]}))
    {
        if (p{t.[TPOS]} == '\n')
        {
            t.[TCOL] = 0;
            t.[TLINE] += 1;
        }
        t.[TCOL] += 1;
        if ((t.[TPOS] += 1) >=! t.[TSRC].[STRINGLEN])
        {
            out.[TOKEN_TYPE] = TEND;
            return TRUE;
        }
    }

    if (p{t.[TPOS]} == '#')
    {
        while (p{t.[TPOS] += 1} != '\n')
        {
            if (t.[TPOS] >=! t.[TSRC].[STRINGLEN])
            {
                out.[TOKEN_TYPE] = TEND;
                return TRUE;
            }
        }
        t.[TLINE] += 1;
        t.[TCOL] = 1;
        JMP .skip
    }

    c = p{t.[TPOS]};
    if (isnum(c)) return tokenizer_number_token(t, out);
    if (isalpha(c)) return tokenizer_ident_token(t, out);
    if (c == '\'') return tokenizer_string_token(t, out, TCHARS);
    if (c == '"') return tokenizer_string_token(t, out, TSTRING);

    return tokenizer_symbol_token(t, out);
}