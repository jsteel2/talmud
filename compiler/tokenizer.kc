struct TOKENIZER = [TSRC], [TPOS], [TCOL], [TLINE];

struct TEND = {TINVALID}, {TNUM}, {TIDENT}, {TCHARS}, {TSTRING};

struct TOKEN = [TOKEN_TYPE], STRING{TOKEN_VALUE};

function tokenizer_init(t, src)
{
    t.[TSRC] = src;
    t.[TPOS] = 0;
    t.[TCOL] = 1;
    t.[TLINE] = 1;
}

function tokenizer_number_token(t, out)
{
    return FALSE;
}

function tokenizer_ident_token(t, out)
(s{STRING}, p)
{
    p = t.[TSRC].[STRINGPTR];
    s.[STRINGPTR] = &p{t.[TPOS]};
    s.[STRINGLEN] = 0;
    do
    {
        s.[STRINGLEN] += 1;
        t.[TPOS] += 1;
    } while (t.[TPOS] <! t.[TSRC].[STRINGLEN] and (isalnum(p{t.[TPOS]}) or p{t.[TPOS]} == '_'));

    t.[TCOL] += s.[STRINGLEN];
    
    memcpy(&out.{TOKEN_VALUE}, s, STRING);

    p = s.[STRINGLEN];
    #switch (s.[STRINGPTR]{0})
    #{
    #    case 'w':
    #        if (p == 5)
    #        {
    #            if (strcmp(s, "while")) out.[TOKEN_TYPE] = TWHILE;
    #            else break;
    #        }
    #        return TRUE;
    #}

    out.[TOKEN_TYPE] = TIDENT;
    return TRUE;
}

function tokenizer_string_token(t, out, type)
{
    return FALSE;
}

function tokenizer_symbol_token(t, out)
{
    return FALSE;
}

function tokenizer_token(t, out)
(c, p)
{
    if (t.[TPOS] >=! t.[TSRC].[STRINGLEN])
    {
        out.[TOKEN_TYPE] = TEND;
        return TRUE;
    }

    p = t.[TSRC].[STRINGPTR];

.skip:
    while (isspace(p{t.[TPOS]}))
    {
        if (p{t.[TPOS]} == '\n')
        {
            t.[TCOL] = 0;
            t.[TLINE] += 1;
        }
        t.[TCOL] += 1;
        if ((t.[TPOS] += 1) >=! t.[TSRC].[STRINGLEN])
        {
            out.[TOKEN_TYPE] = TEND;
            return TRUE;
        }
    }

    if (p{t.[TPOS]} == '#')
    {
        while (p{t.[TPOS] += 1} != '\n')
        {
            if (t.[TPOS] >=! t.[TSRC].[STRINGLEN])
            {
                out.[TOKEN_TYPE] = TEND;
                return TRUE;
            }
        }
        t.[TLINE] += 1;
        t.[TCOL] = 1;
        JMP .skip
    }

    c = p{t.[TPOS]};
    if (isnum(c)) return tokenizer_number_token(t, out);
    if (isalpha(c)) return tokenizer_ident_token(t, out);
    if (c == '\'') return tokenizer_string_token(t, out, TCHARS);
    if (c == '"') return tokenizer_string_token(t, out, TSTRING);

    return tokenizer_symbol_token(c, out);
}