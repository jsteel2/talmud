enum MODMEM, MODDISPB, MODDISPW, MODREG;
enum SIBSCALE1, SIBSCALE2, SIBSCALE4, SIBSCALE8;

enum REAX, RECX, REDX, REBX, RESP, REBP, RESI, REDI;
const RSIB = RESP;
const RDISP = REBP;
const SIBNOINDEX = RESP;

const OTESTW = 0x85, OJMPW = 0xE9, OCALL = 0xE8, OMOVMRB = 0x88, OMOVMRW = 0x89, OMOVRMB = 0x8A, OMOVRMW = 0x8B, OMOVRIMMW = 0xB8, OMOVMIMMW = 0xC7, OMOVMIMMB = 0xC6, OJZW = 0x840F, OJZB = 0x74, OJNZW = 0x850F, OPUSHR = 0x50, OPOPR = 0x58, OGRP1MIMMWB = 0x83, OGRP1MIMMBB = 0x80, OGRP1MIMMWW = 0x81, OGRP1ADD = 0, OGRP1AND = 4, OGRP1OR = 1, OGRP1XOR = 6, OGRP1SUB = 5, OGRP1CMP = 7, OGRP5 = 0xFF, OGRP5CALL = 2, OLEAVE = 0xC9, ORET = 0xC3, OMOVZXW = 0xB70F, OMOVZXB = 0xB60F, OLEA = 0x8D, OSIZEOVERRIDE = 0x66, OGRP3W = 0xF7, OGRP3MUL = 4, OGRP3IMUL = 5, OSETZ = 0x940F, OSETNZ = 0x950F, OANDEAXIMMW = 0x25, OOREAXIMMW = 0x0D, OXOREAXIMMW = 0x35, OCMPEAXIMMW = 0x3D, OADDEAXIMMW = 0x05, OSUBEAXIMMW = 0x2D, ONOP = 0x90, OCMPMRW = 0x39, OSETA = 0x970F, OSETG = 0x9F0F, OSETAE = 0x930F, OSETGE = 0x9D0F, OSETB = 0x920F, OSETL = 0x9C0F, OSETBE = 0x960F, OSETLE = 0x9E0F, OADDMRB = 0x00, OADDRMB = 0x02, OADDRMW = 0x03, OADDMRW = 0x01, OCLD = 0xFC, OSTD = 0xFD, OREP = 0xF3, OMOVSB = 0xA4, ODECR = 0x48, OCMPSB = 0xA6, OSTOSB = 0xAA;

function modrm(mod, reg, rm) return (mod << 6) | (reg << 3) | rm;
const sib = modrm;

function compiler_asm_reg(c, outsize)
(t)
{
    if (!(t = compiler_matches(c, TAX, TEDI))) return -1;
    if (t >=! TAL and t <=! TBH)
    {
        *outsize = 8;
        return t - TAL;
    }
    else if (t >=! TAX and t <=! TDI)
    {
        *outsize = 16;
        return t - TAX;
    }
    *outsize = 32;
    return t - TEAX;
}

function compiler_asm_sizeoverride(c, size)
{
    if ((size == 32 and !c{CUSE32}) or (size == 16 and c{CUSE32})) compiler_emit8(c, 0x66);
}

function compiler_asm_addroverride(c, size)
{
    if ((size == 32 and !c{CUSE32}) or (size == 16 and c{CUSE32})) compiler_emit8(c, 0x67);
}

struct CASMEMDATA = {CASMEMADDRSIZE}, {CASMEMMODRM}, {CASMEMSIB}, [CASMEMDISP];
function compiler_asm_mem(c, outsize, mem)
(base, ident{COMPILER_IDENT})
{
    *outsize = 0;

    if (!compiler_match(c, TLEFTBRACKET)) return FALSE;

    base = TINVALID;

    if (base == TINVALID and compiler_match(c, TIDENT) and map_get(&c{CLOCALS}, &c{CCUR + TOKEN_VALUE}, ident))
    {

        base = TEBP;
        mem{CASMEMMODRM} = modrm(MODDISPW, 0, REBP);
        mem{CASMEMADDRSIZE} = 32;
        compiler_asm_addroverride(c, 32);
        mem.[CASMEMDISP] = ident.[COMPILER_IDENT_ADDR];
    }

    compiler_consume(c, TRIGHTBRACKET);
}

function compiler_asm_emitmem(c, mem, reg)
{
    compiler_emit8(c, modrm(0, reg, mem{CASMEMMODRM}));
    if (mem{CASMEMADDRSIZE} == 32 and (mem{CASMEMMODRM} & 0x7) == 0x4) compiler_emit8(c, mem{CASMEMSIB});
    if ((mem{CASMEMMODRM} & 0x7) == (mem{CASMEMADDRSIZE} == 16 ? 0x6 : 0x5) or (mem{CASMEMMODRM} >> 6) == 0x2)
    {
        if (mem{CASMEMADDRSIZE} == 16) compiler_emit16(c, mem.<CASMEMDISP>);
        else compiler_emit32(c, mem.[CASMEMDISP]);
    }
}

function compiler_asm_mov(c)
(dest, destsize, src, srcsize, mem{CASMEMDATA})
{
    compiler_advance(c);
    if ((dest = compiler_asm_reg(c, &destsize)) != -1)
    {
        compiler_consume(c, TCOMMA);
        if ((src = compiler_asm_reg(c, &srcsize)) != -1)
        {
            if (destsize != srcsize) compiler_throw(c, $@, $*, format(print, "operand size mismatch: dest %u != src %u", destsize, srcsize));
            compiler_asm_sizeoverride(c, destsize);
            compiler_emit8(c, destsize == 8 ? OMOVRMB : OMOVRMW);
            compiler_emit8(c, modrm(MODREG, dest, src));
        }
        else if (compiler_asm_mem(c, &srcsize, mem))
        {
            if (srcsize != 0 and srcsize != destsize) compiler_throw(c, $@, $*, format(print, "operand size mismatch: dest %u != src %u", destsize, srcsize));
            compiler_asm_sizeoverride(c, destsize);
            compiler_emit8(c, destsize == 8 ? OMOVRMB : OMOVRMW);
            compiler_asm_emitmem(c, mem, dest);
        }
        else
        {
            compiler_throw(c, $@, $*, print("Invalid form"));
        }
    }
    else
    {
        compiler_throw(c, $@, $*, print("Invalid form"));
    }
}

function compiler_asm_grp1(c, base, reg)
(dest, destsize, src, srcsize, mem{CASMEMDATA})
{
    compiler_advance(c);
    if ((dest = compiler_asm_reg(c, &destsize)) != -1)
    {
        compiler_consume(c, TCOMMA);
        if (compiler_asm_mem(c, &srcsize, mem))
        {
            if (srcsize != 0 and srcsize != destsize) compiler_throw(c, $@, $*, format(print, "operand size mismatch: dest %u != src %u", destsize, srcsize));
            compiler_asm_sizeoverride(c, destsize);
            compiler_emit8(c, base + (destsize == 8 ? OADDRMB : OADDRMW));
            compiler_asm_emitmem(c, mem, dest);
        }
        else
        {
            compiler_throw(c, $@, $*, print("Invalid form"));
        }       
    }
    else
    {
        compiler_throw(c, $@, $*, print("Invalid form"));
    }       
}

function compiler_asm_incdec(c, op)
(dest, destsize)
{
    compiler_advance(c);
    if ((dest = compiler_asm_reg(c, &destsize)) != -1)
    {
        if (destsize == 8)
        {
            compiler_throw(c, $@, $*, print("Unimplemented"));
        }
        else
        {
            compiler_asm_sizeoverride(c, destsize);
            compiler_emit8(c, op | dest);
        }
    }
    else
    {
        compiler_throw(c, $@, $*, print("Invalid form"));
    }
}

function compiler_asm_jcc(c, opb, opw)
(econst, r)
{
    compiler_advance(c);
    if (compiler_match(c, TSHORT))
    {
        r = compiler_expression(c, &econst);
        if (!econst or r >! 0xFF) compiler_throw(c, $@, $*, print("invalid asm expression"));
        compiler_emit8(c, opb);
        compiler_emit8(c, r);
    }
    else
    {
        r = compiler_expression(c, &econst);
        if (!econst or (!c{CUSE32} and r >! 0xFFFF)) compiler_throw(c, $@, $*, print("invalid asm expression"));
        compiler_emit16(c, opw);
        if (c{CUSE32}) compiler_emit32(c, r);
        else compiler_emit16(c, r);
    }
}